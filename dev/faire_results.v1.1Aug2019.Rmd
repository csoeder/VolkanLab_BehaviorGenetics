---
title: "Volkan Lab Faire-Seq"
author: "Charlie Soeder"
date: "8/1/2019"
output:
  pdf_document: 
    number_sections: yes
    toc: yes
    toc_depth: 5
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/proj/cdjones_lab/csoeder/volkan_faire/')
#knitr::opts_knit$set(root.dir=peaDubDee)
library("biomaRt")
library("org.Dm.eg.db")

library("yaml")
library("readr")
library("tidyverse")
library("ggnewscale")
library("scales")

#install.packages("remotes")
#remotes::install_github("rstudio/gt")
library("gt")
library("GGally")

```





```{r include=FALSE}

human_readable_croncher <- function(num_in) {
	dig <- 3
	num_out <- formatC(num_in, digits=dig, format='g') %>% as.numeric() %>% sitools::f2si()
	return(num_out)
}

bam_summary_loader <- function(filename, aligner="bwa", reference='dm6'){
	
	tmp.df <- read_delim(filename, "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
	names(tmp.df) <- c("sample","measure","value")
	
	tmp.df$sample <- as.factor(tmp.df$sample)
	tmp.df$measure <- as.factor(tmp.df$measure)
	tmp.df$aligner <- as.factor(aligner)
	tmp.df$reference <- as.factor(reference)
	
	return(tmp.df)
	
}
```




# Introduction

words words



# Materials, Methods, Data, Software

```{r include=FALSE}

trammel <- read_yaml("config.yaml")

```
generic overview words


## Reference Genomes


```{r include=FALSE}
refGenomes_summary_df <- read_delim("meta/reference_genomes.summary", 
    "\t", escape_double = FALSE, col_names = FALSE, 
    trim_ws = TRUE)

names(refGenomes_summary_df) <- c("refGenome","measure","value")

```

```{r include=FALSE}
# 
# t1 <- kable(head(mtcars)[1:3], format = "latex", booktabs = TRUE)
# t2 <- kable(head(mtcars)[4:6], format = "latex", booktabs = TRUE)
# 
# cat(c("\\begin{table}[!htb]
#     \\begin{minipage}{.5\\linewidth}
#       \\caption{}
#       \\centering",
#         t1,
#     "\\end{minipage}%
#     \\begin{minipage}{.5\\linewidth}
#       \\centering
#         \\caption{}",
#         t2,
#     "\\end{minipage} 
# \\end{table}"
# ))  
# https://stackoverflow.com/questions/38036680/align-multiple-tables-side-by-side
```

The dm6 reference genome was used for read alignment:
```{r echo=FALSE}

refGenomes_summary_df  %>% mutate(measure=gsub("_"," ",measure)) %>% spread(refGenome, value)   %>% gt() %>% tab_header(title="Size and Consolidation of Reference Genomes", subtitle="Drosophila Melanogaster") %>%   fmt_number(columns = vars(dm6),suffixing = TRUE, decimals=0)

```

## Reference Annotations

Reference annotations were used to locate features within the genome for comparison:

```{r include=FALSE}

ref_ann.stats <- read_delim("meta/reference_annotations.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(ref_ann.stats) <- c("annot", "measure", "type", "value")

ref_ann.stats %>%  filter(type == 'total' | type == 'avg') %>% unite("measure", c("type", "measure"), sep = " ") %>% spread(measure, value) %>% gt()

```

## Sequenced Reads
```{r include=FALSE}
data_sets.df <- plyr::ldply(trammel$data_sets, data.frame)
data_sets.df$name <- as.factor(data_sets.df$name)
data_sets.df$day<- as.factor(data_sets.df$day)
data_sets.df$experimental <- gsub("_", "-", data_sets.df$experimental)
data_sets.df$experimental<- as.factor(data_sets.df$experimental)
data_sets.df$subgroups<- as.factor(data_sets.df$subgroups)
data_sets.df$rep<- as.factor(data_sets.df$rep)

data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,path,readsfile)) %>% distinct() 

```


FAIRE-Seq reads were sequenced for four experimental treatments. Each had one "input" (in which the DNA was fragmented without crosslinking to chromatin) and three replicates in which the DNA was crosslinked and then fragmented. 

```{r echo=FALSE, results='asis'}
data_sets.df.sparse  %>% group_by(experimental,rep) %>% summarise(`sample count`=n())  %>% gt() %>%  tab_options(row_group.background.color = "#FFEFDB") 
```



### Pre-Processing

These reads were preprocessed with FASTP [@Chen2018] for quality control and analytics. 


```{r echo=FALSE, include=FALSE, warning=FALSE}
fastp_summary <- read_delim("meta/sequenced_reads.dat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(fastp_summary ) <- c("name","type","measure","value")
fastp_summary$name <- as.factor(fastp_summary$name)
fastp_summary$type <- as.factor(fastp_summary$type)
fastp_summary$measure <- as.factor(fastp_summary$measure)
```


```{r echo=FALSE, include=FALSE, warning=FALSE}
filtration_stats <- inner_join(fastp_summary %>%  filter(type=="prefiltered" | type == 'postfiltered'), data_sets.df.sparse, by=c("name"="name"))
filtration_stats$type <- factor(filtration_stats$type, levels=c("prefiltered", "postfiltered"))
```


Starting FASTQ files contained a total of  $`r sum( filtration_stats %>% filter(type =='prefiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$ reads; after QC, this dropped to $`r sum( filtration_stats %>% filter(type =='postfiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$. 



```{r echo=FALSE, warning=FALSE, message=FALSE }
pre_post_counts <- filtration_stats %>% filter(measure=='total_reads') %>%  group_by(type)  %>%  summarise(minimum = min(value), average=mean(value) , maximum = max(value)) 
retention_percent <- filtration_stats %>% filter(measure=='total_reads') %>% select(c(name,type,value)) %>%  spread(type,value) %>% mutate(retention=100*postfiltered/prefiltered) %>%  summarise(type='percent retention', minimum = min(retention), average=mean(retention) , maximum = max(retention))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
rbind(pre_post_counts, retention_percent) %>% rename(" "=type) %>% gt() %>% tab_header(title="Read Retention Rate during Preprocessing", subtitle= md("&nbsp;")) %>%  fmt_number(columns = vars(minimum, average,maximum),suffixing = TRUE, decimals=0)
```



```{r echo=FALSE, warning=FALSE}
ggplot(filtration_stats %>% filter(measure == "q30_rate")) + geom_line(aes(group=name, x=type,y=100*value)) +  geom_point(aes(x=type, y = 100*value, color=experimental, shape=rep)) + labs(title = "Percent of Reads with a mean QUAL > 30", y="Percent QUAL > 30", x="") + ggbio::theme_clear() + geom_text(data= . %>% filter(type=="postfiltered") %>% filter(value<0.97), aes(type,100*value,label=name))

```


Duplicate reads were also detected; however, duplicate reads are less concerning in FAIRE-seq given the relatively smaller genome they are sampled from. 

https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/8%20Duplicate%20Sequences.html
http://seqanswers.com/forums/showthread.php?t=40440


```{r echo=FALSE, include=FALSE}
dupe_stats <- inner_join(fastp_summary %>% filter(type=='duplication' & measure =='rate') %>%  mutate(percent=value*100) %>% select(c(name,percent)), data_sets.df.sparse, by=c("name"="name"))
```

```{r echo=FALSE}
dupe_stats %>%  summarise(minimum = min(percent), average=mean(percent), median=median(percent) , maximum = max(percent)) %>% gt() %>% tab_header(title="Percentage Duplication", subtitle="FASTP estimate") %>% fmt_number(columns=vars(minimum,median,average,maximum), decimals=1, ) #kable(caption="Percentage Duplication",digits=1)
```

```{r echo=FALSE}
ggplot(dupe_stats) + geom_histogram(aes(x=percent, fill=experimental), bins=15) + labs(title="Duplication Histogram", x="Read Duplication Rate (FASTP estimate)", y="Number Samples") + ggbio::theme_clear()
```

```{r echo=FALSE}

#ggplot(inner_join(dupe_stats,filtration_stats %>% filter(measure=="total_reads"), by=c("name"="name"))) + geom_point(aes(x=value, y=percent, color=experimental.x, shape=rep.x)) + facet_grid(.~type) + scale_x_log10() + ggbio::theme_clear()

```


## Mapped Reads

Reads were first mapped to the reference genome using the BWA SAMPE/SE algorithm. Currently, multimapping reads are assigned randomly and the alignments are used unfiltered. 

```{r echo=FALSE, include=FALSE}

vs_dm6.bwa <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwa.summary",aligner="bwa", reference="dm6")
#vs_dm6.bwaUniq <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwaUniq.summary",aligner="bwaUniq", reference="dm6")

all_alignments <- rbind(vs_dm6.bwa)#, vs_dm6.bwaUniq)
```




### Read & Alignment Quality


```{r echo=FALSE, warning=FALSE}
readcount_process <- all_alignments %>%  filter( measure=='total_read_count'| measure == 'total_mapped_count' ) %>% select(-c(reference, aligner))

readcount_process$measure <- factor(readcount_process$measure, levels = c('total_read_count','total_mapped_count'))
```

The mapping rate per sample can be calculated from the number of mapped reads compared to the total number of sequenced reads:

```{r echo=FALSE, warning=FALSE}
ggplot(inner_join(readcount_process%>% mutate(measure=gsub("_"," ",measure)), data_sets.df.sparse, by=c("sample"="name"))) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample,color=experimental, shape=rep))  + labs(title="Read Counts by Processing Step: Unmapped, Mapped, Filtered", x="", y="Number Reads" ) + ggbio::theme_clear() + theme(axis.text.x = element_text(angle = -45, hjust = 0), legend.position='none' ) + scale_y_log10()

```

```{r echo=FALSE}

readcount_process.spread <- readcount_process %>%  spread(measure, value) %>%  mutate(percent_mapping=100*total_mapped_count/total_read_count)#, filter_retention = filtered_mapped_count/total_mapped_count)


readcount_process.spread %>% gather(total_read_count:percent_mapping, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>% mutate(measure=gsub("_"," ",measure)) %>% gt()  %>% tab_header(title="Read Counts During Alignment & Filtration", subtitle= md("&nbsp;")) %>% fmt_number(columns=vars(minimum, average, median, maximum), rows =c(2,3), decimals=1, suffixing=TRUE)%>% fmt_number(columns=vars(minimum, average, median, maximum), rows =c(1), decimals=2)


```

### Depth & Breadth of Coverage


```{r echo=FALSE}
breadth_stats <- inner_join(all_alignments %>% filter(measure=="total_breadth") %>% rename("total_breadth"=value) %>% select(-c(aligner, reference, measure)), data_sets.df.sparse %>% select(-c(day)), by=c("sample"="name") )

```

Depth of coverage is not especially meaningful here, but breadth of coverage may give an indication of background genomic DNA. This explains why the input samples tend to have higher breadth values.

```{r echo=FALSE}

ggplot(breadth_stats %>% mutate(x=0)) + geom_boxplot(aes(y=total_breadth, x=x)) + geom_jitter(aes(y=total_breadth, shape=experimental, color=rep=="input", x=x), size=3, height=0, width=0.1) + ggbio::theme_clear()

```


## Peak Calling

MACS was used to QC pilot data, but it wasn't designed for use on FAIRE-Seq. MACS2 was extended for use with FAIRE (  https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/1756-8935-7-33 ) but has its own difficulties, such as python2/3 incompatibilities, and only running on all samples under inhomogeneous settings. Here, Fseq [@Boyle2008] is used to infer peaks from mapped reads. It does this using a kernel density estimation to find intervals with significantly (4 sigma by default) more mapped reads than expected from the average regional coverage. Additionally, a signal strength is calculated, as the highest per-basepair significance in the interval. 

```{r echo=FALSE, warning=FALSE, message=FALSE}

basicPeakStats_vs_dm6_bwa <- read_delim("meta/basicPeakStats.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% as_tibble()
names(basicPeakStats_vs_dm6_bwa ) <- c("sample","dataType","dataSubtype","value")
basicPeakStats_vs_dm6_bwa$sample <- as.factor(basicPeakStats_vs_dm6_bwa$sample)
basicPeakStats_vs_dm6_bwa$dataType<- as.factor(basicPeakStats_vs_dm6_bwa$dataType)
basicPeakStats_vs_dm6_bwa$dataSubtype<- as.factor(basicPeakStats_vs_dm6_bwa$dataSubtype)

```

from the $`r basicPeakStats_vs_dm6_bwa %>% select(sample) %>% unique() %>% count() `$ samples,  $`r basicPeakStats_vs_dm6_bwa %>% filter(dataType=="count" & dataSubtype == "total") %>% select(value) %>% sum() %>% human_readable_croncher() `$ total peaks were called:

```{r echo=FALSE}
basicPeakStats_vs_dm6_bwa.count.sprud <- basicPeakStats_vs_dm6_bwa %>% filter(dataType == "count") %>% select(-c(dataType)) %>% spread(dataSubtype,value)

contigs <- basicPeakStats_vs_dm6_bwa.count.sprud %>% select(3:ncol(.)-1) %>% names()

basicPeakStats_vs_dm6_bwa.count.sprud %>% gt()  %>%  tab_spanner(label="by contig", columns=vars(contigs ))  %>% tab_header(title="Called Peak Count", subtitle= "by contig and sample")

```

We can also check the peak-calling efficiency:

```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.count.sprud.aug <- inner_join(inner_join(basicPeakStats_vs_dm6_bwa.count.sprud %>% select(c("sample","total")), data_sets.df.sparse , by = c("sample"="name")), readcount_process.spread, by=c("sample"="sample")) %>% rename("total_peak_count"=total) %>% mutate(peaks_per_thousand_sequenced_reads = 1000*total_peak_count/total_read_count, peaks_per_thousand_mapped_reads = 1000*total_peak_count/total_mapped_count)

basicPeakStats_vs_dm6_bwa.count.sprud.aug  %>% select(-c("sample", "day")) %>% select_all(~gsub("_"," ",.)) %>%  gt() %>% cols_move_to_start(columns = vars(experimental, rep)) %>% fmt_number(columns = vars(`total peak count`), suffixing = T, decimals = 1) %>% fmt_number(columns = vars(`peaks per thousand sequenced reads`, `peaks per thousand mapped reads`),  decimals = 1) %>% cols_hide(columns=vars(`total read count`, `total mapped count`, `percent mapping`)) %>% cols_label(`peaks per thousand sequenced reads` = "peaks per\nthousand sequenced reads", `peaks per thousand mapped reads`= "peaks per\nthousand mapped reads")  %>% tab_header(title="Peak Calling Efficiency", subtitle= "peaks called per read sequenced/mapped")

```




```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.size.sprud <- basicPeakStats_vs_dm6_bwa %>% filter(dataType == "width" | dataType == "signal") %>% unite(dataSubtype, dataType, col="measure", sep=" ")  %>% spread(measure, value) %>% select(sample, `avg width`, `std width`, `avg signal`, `std signal`)

basicPeakStats_vs_dm6_bwa.size.sprud.aug <- inner_join(inner_join(basicPeakStats_vs_dm6_bwa.size.sprud, data_sets.df.sparse , by = c("sample"="name")),readcount_process.spread, by=c("sample"="sample") )

	
grand_mean_peak_width <- mean(basicPeakStats_vs_dm6_bwa.size.sprud$`avg width`)
grand_mean_signal <- mean(basicPeakStats_vs_dm6_bwa.size.sprud$`avg signal`)
```

peaks had an average width of $`r human_readable_croncher(grand_mean_peak_width) `$ base pairs. Peaks also had intensity values measuring signal enhancement over the genomic background; these averaged at $`r human_readable_croncher(grand_mean_signal) `$ Both of these values were highly variable within and between samples:


```{r gt, echo=FALSE}

basicPeakStats_vs_dm6_bwa.size.sprud.aug %>% select(experimental, rep, `avg width`, `std width`, `avg signal`, `std signal`) %>% gt() %>%  tab_spanner(label="width", columns=vars( `avg width`, `std width`)) %>%  tab_spanner(label="signal", columns=vars( `avg signal`, `std signal` )) %>% fmt_number(columns = vars(`avg width`, `std width`, `avg signal`, `std signal` ), decimals = 1, suffixing = F) %>% tab_header(title="Peak Size & Signal Strength", subtitle= md("&nbsp;")) %>% cols_label(`avg width` = "avg", `std width` = "std", `avg signal` = "avg", `std signal` = "std" )

```

```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.full.sprud.aug <- inner_join(basicPeakStats_vs_dm6_bwa.size.sprud.aug, basicPeakStats_vs_dm6_bwa.count.sprud.aug %>% select(-c(experimental,day,rep, total_read_count, total_mapped_count, percent_mapping)), by=c("sample"="sample")  )

#ggpairs(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg width", "avg signal",  "total_read_count", "total_mapped_count", "percent_mapping", "total_peak_count" ), mapping=aes(color=experimental))


basicPeakStats_vs_dm6_bwa.full.sprud.aug.names <- basicPeakStats_vs_dm6_bwa.full.sprud.aug %>% names()
names(basicPeakStats_vs_dm6_bwa.full.sprud.aug) <- gsub(" ","\n", gsub("_", "\n", basicPeakStats_vs_dm6_bwa.full.sprud.aug %>% names()))

ggscatmat(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg\nwidth", "std\nwidth", "avg\nsignal", "std\nsignal", "total\nread\ncount", "total\nmapped\ncount", "total\npeak\ncount" )) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title="Distributions & Correlations for Read and Peak Stats")

```


```{r echo=FALSE}
#ggscatmat(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg\nwidth", "avg\nsignal", "total\nread\ncount", "total\nmapped\ncount", "percent\nmapping",  "total\npeak\ncount" ), color="experimental") + theme(axis.text.x = element_text(angle = 90, hjust = 1))

names(basicPeakStats_vs_dm6_bwa.full.sprud.aug) <- basicPeakStats_vs_dm6_bwa.full.sprud.aug.names 

```



```{r echo=FALSE, message=FALSE}
raw_called_peaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$name) {
	
	tmp.df <- read_delim(paste("fSeq/",nom,".vs_dm6.bwa.calledPeaks.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% select(X1,X2,X3,X7,X10)
	names(tmp.df) <- c("chrom", "start", "stop", "signal", "center")
	tmp.df$sample <- as.factor(nom)
	raw_called_peaks.df <- rbind(raw_called_peaks.df, tmp.df)
}

raw_called_peaks.df <- raw_called_peaks.df %>% as_tibble()
raw_called_peaks.df$chrom <- as.factor(raw_called_peaks.df$chrom)

raw_called_peaks.df$peak_width <- raw_called_peaks.df$stop - raw_called_peaks.df$start
raw_called_peaks.df <- inner_join(raw_called_peaks.df, data_sets.df.sparse, by=c("sample"="name"))

```


of the $`r basicPeakStats_vs_dm6_bwa %>% filter(dataType=="count" & dataSubtype == "total") %>% select(value) %>% sum() %>% human_readable_croncher() `$ peaks, $`r raw_called_peaks.df %>% filter(peak_width==0) %>% nrow() %>% human_readable_croncher() `$ had a width of zero


```{r echo=FALSE, warning=FALSE}

ggplot(raw_called_peaks.df %>% gather(signal, peak_width, key="measure", value="value")) + geom_histogram(aes(x=value, fill=experimental), bins=50) +facet_grid(chrom~measure, scales="free") + scale_x_log10() + theme_bw() + labs(title="Histogram of Peak Width & Signal Strength,\nby Chromosome")

```

The consistent spike in peak width in the 47b1-7 experiment, slightly above 1kb, comes from replicate 3. This sample has an order of magnitude more peaks large than 1kb, than the other 15.

```{r echo=FALSE}
raw_called_peaks.df %>% filter(peak_width > 1000 )  %>% group_by(experimental, rep) %>% summarize(n=n()) %>%  spread(rep, n) %>% ungroup() %>% gt() %>% tab_options(footnote.glyph = c("*")) %>% tab_style(style=cells_styles(text_color='red'), locations=list(cells_data(columns=vars(3), rows=experimental == "47b1-7"))) %>%  tab_footnote(footnote = "  ", locations=list(cells_data(columns=vars(3), rows=experimental == "47b1-7"))) %>% tab_header(title="Number of Peaks Larger than 1 kb", subtitle= "by experiment and replicate")

```

47b1-7 replicate #3 is only included in the "C" analysis group (Section 2.6). 




check intrasample, inter-peak distances: look for potentially non-distinct peaks. 
```{r echo=FALSE, message=FALSE}

calledPeaks.selfDistance.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$name) {
	tmp.df <- read_delim(paste("fSeq/closest/all/",nom,".to.",nom,  ".vs_dm6.bwa.closestPeaks.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)
	#names(tmp.df) <- c("chrom", "start", "stop", "signal", "center")
	calledPeaks.selfDistance.df  <- rbind(calledPeaks.selfDistance.df , tmp.df)
}

calledPeaks.selfDistance.df <- calledPeaks.selfDistance.df  %>% as_tibble() %>% select(c(X1,X2,X3,X7,X10,X11,X12,X13,X17,X20,X21,X22))
names(calledPeaks.selfDistance.df) <- c("chrom1", "start1", "stop1", "signal1", "center1", "chrom2", "start2", "stop2", "signal2", "center2", "distance", "sample" )
calledPeaks.selfDistance.df$chrom1 <- as.factor(calledPeaks.selfDistance.df$chrom1)
calledPeaks.selfDistance.df$chrom2 <- as.factor(calledPeaks.selfDistance.df$chrom2)
calledPeaks.selfDistance.df$sample <- as.factor(calledPeaks.selfDistance.df$sample)

calledPeaks.selfDistance.df <- inner_join(calledPeaks.selfDistance.df, data_sets.df.sparse, by=c("sample"="name"))


```


The distance between adjacent peaks within a sample was measured. 


```{r echo=FALSE}

ggplot(calledPeaks.selfDistance.df %>% filter(chrom1 != "chrM")) + geom_freqpoly(aes(x=abs(distance), color=rep), bins=50) + facet_grid(experimental ~ chrom1) + scale_x_log10() +theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Distance Between Adjacent Peaks,\nby sample and replicate", x= "distance (bp)")

```

Some peaks were very close to other peaks; as many as 20% of peaks were within 10bp of another one, and as many as 65% were within 100 bp:

```{r echo=FALSE}
closePeaks <- calledPeaks.selfDistance.df %>% filter(abs(distance)<10) %>% group_by(sample) %>% summarise(lessThan10 = n() )
closePeaks <- cbind( closePeaks, calledPeaks.selfDistance.df %>% filter(abs(distance)<100) %>% group_by(sample) %>% summarise(lessThan100 = n() ) %>% select(lessThan100))

#closePeaks <- 
inner_join(closePeaks, basicPeakStats_vs_dm6_bwa.full.sprud.aug, by=c("sample"="sample")) %>% mutate(lessThan10 = lessThan10/total_peak_count, lessThan100 = lessThan100/total_peak_count, potato = "")  %>% select(experimental, rep, lessThan10, lessThan100, potato) %>% group_by(experimental) %>% gt(rowname_col = "potato") %>% fmt_percent(columns=vars(lessThan10, lessThan100), decimals = 1) %>% tab_stubhead_label(label="experimental treatment") %>% cols_label(lessThan10 = "< 10 bp", lessThan100 = "< 100 bp") %>% tab_header(title="Percentage of Peaks Very Close to Other Peaks", subtitle= "within a sample")

#ggplot(calledPeaks.selfDistance.df %>% mutate(one=stop1-start1, two = stop2-start2, distance=abs(distance)) %>% select(one, two, distance, experimental, rep) %>% gather(one, two, key="peak", value="width") ) + geom_point(aes(x=distance, y=width), alpha=0.1) + facet_grid(.~peak)

```

## Peak analysis


goal is to find peaks which are present in input but not reps /vice versa

Once the peaks were called, they were further analyzed by merging and contrasting across replicate partition (input vs 1-3) using BEDtools[@Quinlan2010].

To accomodate varying data quality, analyses were done on three nested subsets of the data, each including an input and at least one replicate for each experimental treatment. Groups A, B, and C correspond to 1, 2, and 3:

```
ok, do the alignment and MACS2 analysis like you did before.  Do three version: 

1) Only unmarked
2) include the orange
3) all date
```
(Corbin, 20 May 2019 email)

```{r gt table}

data_sets.df %>% select(c(experimental, rep, subgroups)) %>% mutate(dummy="1") %>% filter(subgroups!='all') %>% group_by_at(vars(-dummy)) %>%  mutate(rowid=1:n()) %>% ungroup() %>% spread(key=subgroups, value=dummy ) %>%  select(-rowid) %>% mutate(A=case_when(is.na(A) ~ "x", TRUE ~ "o" ), B=case_when(is.na(B) ~ "x", TRUE ~ "o" ) , C=case_when(is.na(C) ~ "x", TRUE ~ "o" )  ) %>% gt() %>% tab_style(style = cells_styles(text_style = "italic", text_color="red"), locations = list(cells_data(columns = vars(A), rows = A=="x"), cells_data(columns = vars(B), rows = B=="x")))

```

Within each group, experimental treatment, and replicate partition, peaks were merged into a single interval if they came within an arbitrary threshold (100 bp) of one another to produce "collapsed" peaks, thus consolidating inconsistent evidence across treatments as well as merging peaks which are likely not distinct molecular events. Presence of a peak in any replicate was sufficient for presence of a merged peak. Peaks were then classified according to their overlap: exclusive to input, exclusive to output, and shared between. 
TODO: implement merging of signal strength scores

A randomized background distribution was made by scrambling the peaks around on their chromosome, allowing none to overlap. (bedtools shuffle with the options -chrom -noOverlapping ). Five such permutations were made for each combination of group, experimental treatment, and overlap state.

TODO: currently scrambling the called, collapsed, partioned peaks - is itbetter to scramble earlier (right after calling?)

Collapsed peaks, measured or randomized, were compared with annotations (subsets of the FlyBase dm6.13 genes and the dm6 RepeatMasker track) for overlaps and proximity using BedTools. 


## Gene Ontology

Gene ontology enrichment for various gene lists (eg, genes overlapped by a peak in the output but not input of Fru7) was testing using topGO. Currently, the Fisher test is used to estimate significance, since we are using gene counts rather than scores 
TODO: roll signal scores into this

Additionally, a number of GO terms and genes had to be masked to suppress a bizarre error that I haven't figured out yet:
https://www.biostars.org/p/311104/#311853

```
GO:0110109
GO:0120176
GO:0120177
GO:0120170
GO:0062023

FBgn0050046
FBgn0033710
FBgn0050203
FBgn0026721

```


# Results 

basic restatement 

## collapsed reads by group, treatment, and replicate partition. 

Within each sample, nearby peaks were merged, and within each group, treatment, and replicate partition, these merged peaks were themselves merged into intervals which had evidence of open chromatin. 

```{r echo=FALSE, message=FALSE}
collapsedPeaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
	
	for (treat in c("inputs","outputs")){
		
		for (grup in c("A", "B", "C")) {
			
			tmp.df <- read_delim(paste("fSeq/",gsub("-", "_", nom),".vs_dm6.bwa.",treat,".group_",grup,".collapsed.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
			names(tmp.df) <- c("chrom", "start", "stop", "count")
			tmp.df$chrom <- as.factor(tmp.df$chrom)
			tmp.df$treat <- as.factor(treat)
			tmp.df$experimental <- as.factor(nom)
			tmp.df$group <- as.factor(grup)
			collapsedPeaks.df <- rbind(collapsedPeaks.df, tmp.df)
		}
	}
}

collapsedPeaks.df <- collapsedPeaks.df %>% as_tibble()

collapsedPeaks.df$peak_width <- collapsedPeaks.df$stop - collapsedPeaks.df$start

```


```{r echo=FALSE}

collapsedPeaks.df %>% group_by(treat, experimental, group ) %>%  summarise(n=n()) %>% ungroup() %>% spread(treat, n) %>% group_by(group) %>% gt() %>% fmt_number(columns=vars(inputs,outputs),decimals=1, suffixing = T) %>% tab_header(title="Peak Count", subtitle="Merged by Group")

```

The average width of the merged peaks was ranged from ~200bp to ~900 bp. Each merged peak was derived from an average of 1-2 raw peaks in the case of the inputs (where only one sample was merged) and 2-4 peaks in the case of the replicates:

```{r echo=FALSE, warning=FALSE}

collapsedPeaks.df %>% group_by(group, treat, experimental) %>% summarise(avg_width = mean(peak_width), avg_count = mean(count) ) %>% unite(temp, avg_width, avg_count, sep="_") %>% spread(treat, temp) %>% separate(inputs, into=c("avg_input_width", "avg_input_count"), sep="_") %>% separate(outputs, into=c("avg_output_width", "avg_output_count"), sep="_") %>% mutate(avg_input_width=as.numeric(avg_input_width), avg_input_count = as.numeric(avg_input_count), avg_output_width = as.numeric(avg_output_width), avg_output_count=as.numeric(avg_output_count)) %>% gt() %>% tab_spanner(label="input average", columns=vars(avg_input_width,avg_input_count)) %>% tab_spanner(label="output average", columns=vars(avg_output_width,avg_output_count)) %>% cols_label(avg_output_width="width (bp)",avg_output_count="count",avg_input_width="width (bp)",avg_input_count="count",) %>% fmt_number(columns=seq(2,5), decimals=1, suffixing = T) %>% tab_header(title="Peak Merging Averages", subtitle="number merged and final width")

```

47b1 rep 3 shows up again in the group C distribution (see section 2.5)

```{r echo=FALSE, warning=FALSE, message=FALSE}

ggplot(collapsedPeaks.df) + geom_histogram(aes(x=peak_width, fill=experimental), bins=45) +  facet_grid(group~treat) + scale_x_log10() + labs(title="Histogram of Peak Width,\nby experiment, group, and replicate type", x = "peak width (bp)") + theme_bw()

```


### distance within collapsed read sets??


TODO: what is the inter-peak distance distribution within the merged data?


### input - output comparison

within each group & treatment, the merged input and output peaks were compared to identify peaks that were shared between the two cases or exclusive to one. 

#### shared peaks

```{r echo=FALSE, message=FALSE}

##offload some of this to reporter scripts??

shared.collapsedPeaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
		for (grup in c("A", "B", "C")) {
			
			tmp.df <- read_delim(paste("fSeq/",gsub("-", "_", nom),".vs_dm6.bwa.shared.group_",grup,".collapsed.overlap.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
			names(tmp.df) <- c("chrom_in", "start_in", "stop_in", "count_in","chrom_out", "start_out", "stop_out", "count_out", "overlap")
			tmp.df$chrom_in <- as.factor(tmp.df$chrom_in)
			tmp.df$chrom_out <- as.factor(tmp.df$chrom_out)
			tmp.df$experimental <- as.factor(nom)
			tmp.df$group <- as.factor(grup)
			shared.collapsedPeaks.df <- rbind(shared.collapsedPeaks.df, tmp.df)
	}
}

shared.collapsedPeaks.df <- shared.collapsedPeaks.df %>% as_tibble() %>% mutate(width_in = stop_in-start_in, width_out = stop_out-start_out, fraction_overlap = (2*overlap)/(width_in+width_out))

```

A "shared" peak is the union of two or more overlapping peaks, at least one in the merged input and at least one in the merged output. The shared peak count, the average width of the input and output peaks, and the average of the peaks overlapping, are summarized:

```{r echo=FALSE}
shared.collapsedPeaks.df %>% group_by(group, experimental) %>% summarise(count=n(), width_in=mean(width_in),width_out=mean(width_out),percent_overlap=mean(fraction_overlap)) %>% group_by(group) %>% gt() %>% fmt_number(columns=seq(2,4), decimals = 1, suffixing = T) %>% fmt_percent(columns = vars(percent_overlap), decimals = 1) %>% tab_header(title="Shared Peaks", subtitle="and the merged peaks they were drawn from") %>% cols_label(width_in = "input", width_out = "output", percent_overlap = "% overlap")  %>% tab_spanner(label="average component\npeak width (bp)", columns=vars(width_in, width_out))

```

#### exclusive peaks

```{r echo=FALSE, warning=FALSE, message=FALSE}

collapsedPeaksExclusive_vs_dm6_bwa <- read_delim("meta/collapsedPeaksExclusive.vs_dm6.bwa.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% as_tibble()

names(collapsedPeaksExclusive_vs_dm6_bwa) <- c("exclusive", "experimental", "group", "measure", "type", "value")
collapsedPeaksExclusive_vs_dm6_bwa$exclusive <- as.factor(collapsedPeaksExclusive_vs_dm6_bwa$exclusive)
collapsedPeaksExclusive_vs_dm6_bwa$experimental <- as.factor(collapsedPeaksExclusive_vs_dm6_bwa$experimental)
collapsedPeaksExclusive_vs_dm6_bwa$group <- as.factor(collapsedPeaksExclusive_vs_dm6_bwa$group)
collapsedPeaksExclusive_vs_dm6_bwa$measure <- as.factor(collapsedPeaksExclusive_vs_dm6_bwa$measure)
collapsedPeaksExclusive_vs_dm6_bwa$type <- as.factor(collapsedPeaksExclusive_vs_dm6_bwa$type)

```


A peak is "exclusive" if it appears in one of the merged input and output peaks, but does not overlap a anything in the other. A distinction here is that "shared" peaks are new peaks formed from the union of prexisting peaks, but a  "exclusive" peaks are the prexisting peak itself.

```{r echo=FALSE}

collapsedPeaksExclusive_vs_dm6_bwa %>% filter(type =="total" | type == "avg") %>% unite(measure, type, sep="_", col=megameasure) %>% unite(exclusive, group, sep="_", col=supergroup) %>% spread(supergroup, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% mutate(megameasure = recode(megameasure, "count_total" = "total peak count", "num_merged_avg" = "average merged per peak", "width_avg" = "average peak width")) %>% gt() %>% fmt_number(columns = seq(2,7), suffixing=T, decimals=1) %>% tab_spanner(label="input", columns=starts_with("input_")) %>% tab_spanner(label="output", columns=starts_with("output_")) %>% cols_label(input_A="A",input_B="B",input_C="C",output_A="A",output_B="B",output_C="C",megameasure="")%>% tab_header(title="Exclusive Peaks", subtitle="number, size, and raw peaks merged per")

```

TODO: what is distribution of distance from exclusive peak to nearest shared peak?

### peaks overlapping annotated genes

Once partitioned into shared and exclusive piles, the peaks were intersected with the dm6 gene annotation (currently using only the coarse gene locus, no exon/intron divisions etc), and where there were overlaps, both the overlapping peaks and the overlapped genes were noted.

```{r echo=FALSE, message=FALSE, warning=FALSE}
collapsed_intersect_dm6_genes_full <- read_delim("meta/vs_dm6.bwa.collapsed.intersect.dm6_genes.full.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(collapsed_intersect_dm6_genes_full) <- c("partition", "experimental", "group", "measure", "type", "value")
collapsed_intersect_dm6_genes_full$partition <- as.factor(collapsed_intersect_dm6_genes_full$partition)
collapsed_intersect_dm6_genes_full$experimental <- as.factor(collapsed_intersect_dm6_genes_full$experimental)
collapsed_intersect_dm6_genes_full$group <- as.factor(collapsed_intersect_dm6_genes_full$group)
collapsed_intersect_dm6_genes_full$measure <- as.factor(collapsed_intersect_dm6_genes_full$measure)
collapsed_intersect_dm6_genes_full$type <- as.factor(collapsed_intersect_dm6_genes_full$type)
```


```{r echo=FALSE}

collapsed_intersect_dm6_genes_full %>% unite(measure, type, sep="_", col=megameasure) %>% unite(partition, group, sep="_", col=supergroup) %>% mutate(megameasure=recode(megameasure, "count_uniqA"="number peaks overlapping", "count_uniqB"="number genes overlapped", "avg_AperB"="mean peaks per gene","avg_BperA"="mean genes per peak","max_AperB"="max peaks per gene","max_BperA"="max genes per peak")) %>% spread(supergroup, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt() %>% fmt_number(columns = seq(2,10), suffixing=T, decimals=1) %>% fmt_number(columns = seq(2,10), rows=starts_with("max", vars=c(megameasure)) , suffixing=T, decimals=0) %>% tab_spanner(label="exclusive to input", columns=starts_with("input_"))%>% tab_spanner(label="exclusive to output", columns=starts_with("output_")) %>% tab_spanner(label="shared", columns=starts_with("shared_")) %>% cols_label(input_exclusive_A="A",input_exclusive_B="B",input_exclusive_C="C",output_exclusive_A="A",output_exclusive_B="B",output_exclusive_C="C", shared_A="A",shared_B="B",shared_C="C",	megameasure="") %>% tab_header(title="Overlaps between Peaks and Annotated Genes", subtitle= md("&nbsp;"))

```


These patterns are largely driven by outliers (such as large peaks overlapping w/ lots of small genes, eg histone proteins in chr2L:21,481,176-21,544,771 or very large genes like the 1.9M FBgn0267431 ). Genes per peak has a distribution more like:

```
# peaks   genes per peak
   3840 1
    203 2
     21 3
      4 4
      1 5
      1 6
      2 7
      1 12
      1 57
      1 73
      1 100

```




Peaks per gene distribution is more like :


```{r echo=FALSE, message=FALSE, warning=FALSE}

total_dm6_count <- ref_ann.stats %>% filter(annot=="dm6_genes" & measure=="count" & type == "total") %>% select(value) %>% as.integer()

peaksPerGene.hist.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
		for (grup in c("A", "B", "C")) {
			for ( pile in c("shared","output_exclusive","input_exclusive") ){
				tmp.df <- read_delim(paste("features/intersects/",gsub("-", "_", nom),".vs_dm6.bwa.",pile,".group_",grup,".collapsed.intersect.dm6_genes.byGenePeaks.count", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)

				names(tmp.df) <- c("V1", "V2")
				num_zed <- total_dm6_count - nrow(tmp.df)
				tmp.df <- rbind(tmp.df, cbind(rep("potato", num_zed), rep(0, num_zed) ))
				names(tmp.df) <- c("geneId", "peakCount")
				tmp.df$experimental <- as.factor(nom)
				tmp.df$group <- as.factor(grup)
				tmp.df$pile <- as.factor(pile)
				
				

				peaksPerGene.hist.df <- rbind(peaksPerGene.hist.df, tmp.df)
			}
	}
}
peaksPerGene.hist.df$peakCount <- as.integer(peaksPerGene.hist.df$peakCount)

ggplot(peaksPerGene.hist.df) + geom_freqpoly(aes(x=peakCount, color=group), stat="count") + facet_grid(experimental ~ pile) + scale_x_continuous(trans=pseudo_log_trans(base=10), breaks=c(1,10,100,10000), labels = trans_format("log10", math_format(10^.x))) + scale_y_log10() + labs(x= "# peaks per gene", y="count", title="Distribution of Peaks per Gene")

```


An important fact from this table is that, on average, a gene could be expected to have at least one overlapping peak ("mean peaks per gene" rows), meaning that the mere presence of an overlap is not necessarily 


TODO: move g/p and p/g reporting from a snakemake stats script into an onbaord R process for better stats
TODO: refine annotation: exonic vs intronic? 5' vs 3'?
TODO: account for different gene sizes?



```{r echo=FALSE, message=FALSE}
# 
# peakCountsByAnn_dm6_genes <- read_delim("/proj/cdjones_lab/csoeder/volkan_faire/features/intersects/peakCountsByAnn.dm6_genes.tbl", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
# names(peakCountsByAnn_dm6_genes) <- c("experimental","pile","group","gene","count")
# peakCountsByAnn_dm6_genes <- peakCountsByAnn_dm6_genes %>% mutate(experimental = as.factor(experimental),pile = as.factor(pile), group = as.factor(group), gene = as.factor(gene)) %>% as_tibble()
# 
# peakCountsByAnn_dm6_genes <- peakCountsByAnn_dm6_genes %>% spread(pile,count) %>% arrange(gene, experimental, group) %>% select(c(gene, experimental, group, input_exclusive, output_exclusive, shared)) %>%  mutate_all(~replace(., is.na(.), 0))
# 
# write_delim(peakCountsByAnn_dm6_genes, "peakCountsByAnn.dm6_genes.tbl", delim = "\t")


```


### Peaks adjacent to annotated genes

```{r echo=FALSE, message=FALSE, warning=FALSE}


closestGeneOverall.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
		for (grup in c("A", "B", "C")) {
			for ( pile in c("shared","output_exclusive","input_exclusive") ){
				tmp.df <- read_delim(paste("features/closest/",gsub("-", "_", nom),".vs_dm6.bwa.",pile,".group_",grup,".collapsed.closestFeatOverall.dm6_genes.full.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)
				names(tmp.df) <- c("peak_chrom", "peak_start", "peak_stop", "gene_chrom", "gene_start", "gene_stop", "flybase","score", "strand", "gene_name", "distance")
				tmp.df <- tmp.df %>% select(-c(score)) %>% filter(distance !=0)
				tmp.df$peak_chrom <- as.factor(tmp.df$peak_chrom)
				tmp.df$gene_chrom <- as.factor(tmp.df$gene_chrom)
				tmp.df$experimental <- as.factor(nom)
				tmp.df$group <- as.factor(grup)
				tmp.df$pile <- as.factor(pile)

				closestGeneOverall.df <- rbind(closestGeneOverall.df, tmp.df)
			}
	}
}

#remove overlaps and chrM pathologies
closestGeneOverall.df <- closestGeneOverall.df %>%  filter(distance != 0 ) %>% filter(gene_chrom != ".") %>%  mutate(stream=case_when(strand == "+" & distance > 0 ~ "up", strand == "-" & distance < 0 ~ "up", strand == "+" & distance < 0 ~ "down", strand == "-" & distance > 0 ~ "down"))

closestGeneOverall.df.summary <- closestGeneOverall.df %>% group_by(experimental, group, pile, stream == "up") %>% summarise(n=n()) %>% spread(`stream == "up"`, n ) %>% rename(downstream = `FALSE`, upstream = `TRUE`) %>% mutate(frac_down = downstream/(upstream + downstream), frac_up = upstream/(upstream + downstream))


```

Among the peaks which do not overlap an annotated gene, the nearest gene was identified and the peak was classified relative to whether the peak was upstream or downstream.

```{r echo=FALSE}

ggplot(closestGeneOverall.df) + geom_freqpoly(aes(x=abs(distance), color=experimental, linetype=stream )) + facet_grid(group~pile) + scale_x_log10() + scale_y_log10() + theme_bw() + labs(x = "distance (bp)", title= "Distance from Peak to Nearest Gene, Upstream and Downstream")+ theme(axis.text.x = element_text(angle = -45, hjust = 0)) 

```

The most common distances are in the 10k-100kb range. The output-exclusive peaks appear to have an elevated amount of relatively close downstream genes (ie, genes they are upstream to). When the closest gene overall is considered, the fraction which are upstream vs downstream appears to be biased:

```{r echo=FALSE}

ggplot(closestGeneOverall.df.summary) + geom_hline(yintercept=0.5, color="black") + geom_point(aes(x=interaction(group,pile), y=frac_up, color=experimental, shape=group)) + theme(axis.text.x = element_text(angle = -45, hjust = 0) )  + theme_bw() + theme(axis.text.x = element_text(angle = -45, hjust = 0) ) + labs(x="", y="Fraction of Upstream Peaks", title="Fraction of Peaks whose ")


```

Shared and input-exclusive peaks tend to be closer to their genes which are upstream of them (peaks which are downstream), whereas output-exclusive peaks tend to be closer to genes which are downstream of them (peaks which are upstream). The exception is Fru7, which is enhanced for downstream peaks in the output-exclusive pile and for upstream peaks in the input-exclusive pile.  

### Peak association with repetitive elements

```{r echo=FALSE, message = FALSE}

collapsed_intersect_dm6_repeats_full <- read_delim("meta/vs_dm6.bwa.collapsed.intersect.dm6_repeats.full.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(collapsed_intersect_dm6_repeats_full) <- c("partition", "experimental", "group", "measure", "type", "value")
collapsed_intersect_dm6_repeats_full$partition <- as.factor(collapsed_intersect_dm6_repeats_full$partition)
collapsed_intersect_dm6_repeats_full$experimental <- as.factor(collapsed_intersect_dm6_repeats_full$experimental)
collapsed_intersect_dm6_repeats_full$group <- as.factor(collapsed_intersect_dm6_repeats_full$group)
collapsed_intersect_dm6_repeats_full$measure <- as.factor(collapsed_intersect_dm6_repeats_full$measure)
collapsed_intersect_dm6_repeats_full$type <- as.factor(collapsed_intersect_dm6_repeats_full$type)

```

Repetitive DNA, such as low-complexity regions or retroelements, can also be important. Peaks were compared to the dm6 RepeatMasker annotation in the same manner as the gene annotation.

```{r echo=FALSE}

collapsed_intersect_dm6_repeats_full %>% unite(measure, type, sep="_", col=megameasure) %>% unite(partition, group, sep="_", col=supergroup) %>% mutate(megameasure=recode(megameasure, "count_uniqA"="number peaks overlapping", "count_uniqB"="number repeats overlapped", "avg_AperB"="mean peaks per repeat","avg_BperA"="mean repeats per peak","max_AperB"="max peaks per repeat","max_BperA"="max repeat per peak")) %>% spread(supergroup, value)  %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt() %>% fmt_number(columns = seq(2,10), suffixing=T, decimals=1) %>% fmt_number(columns = seq(2,10), rows=starts_with("max", vars=c(megameasure)) , suffixing=T, decimals=0) %>% tab_spanner(label="exclusive to input", columns=starts_with("input_"))%>% tab_spanner(label="exclusive to output", columns=starts_with("output_")) %>% tab_spanner(label="shared", columns=starts_with("shared_")) %>% cols_label(input_exclusive_A="A",input_exclusive_B="B",input_exclusive_C="C",output_exclusive_A="A",output_exclusive_B="B",output_exclusive_C="C", shared_A="A",shared_B="B",shared_C="C",	megameasure="") %>% tab_header(title="Overlaps between Peaks and RepeatMasker Annotations", subtitle= md("&nbsp;"))


```

REVISIT THIS SEE ALSO 3.1.3


## Shared Genes

```{r echo=FALSE, message=FALSE, warning=FALSE}
# 
# closestGeneOverall.df.catByDist <- closestGeneOverall.df %>% select(-c(peak_chrom, peak_start, peak_stop)) %>% mutate(category=case_when(abs(distance) < 100 ~ "I", abs(distance) <1000 & abs(distance) >= 100 ~ "II", abs(distance) < 20000 & abs(distance) >= 1000 ~ "III", abs(distance) >= 20000 ~"IV"))
# 
# closestGeneOverall.df.lookup <- as.data.frame(c())
# for (spear in closestGeneOverall.df.catByDist$experimental %>% unique()){
# 	for (grup in closestGeneOverall.df.catByDist$group %>% unique()){
# 		for (pyle in closestGeneOverall.df.catByDist$pile %>% unique()){
# 			for (cat in closestGeneOverall.df.catByDist$category %>% unique()){
# 				#print(c(spear, grup, pyle, cat))
# 				closestGeneOverall.df.lookup <- rbind(closestGeneOverall.df.lookup , cbind(spear, grup, pyle,  cat))
# 			}
# 		}
# 	}
# }
# 
# names(closestGeneOverall.df.lookup ) <- c("experimental", "group", "pile", "category")
# closestGeneOverall.df.lookup$index <- seq(1,nrow(closestGeneOverall.df.lookup))











# 
# closestGeneOverall.df.sharedGeneFrac <- as.data.frame(c())
# for (ndx1 in closestGeneOverall.df.lookup$index){
# 	for (ndx2 in closestGeneOverall.df.lookup$index){
# 
# 		rho1 <- closestGeneOverall.df.lookup %>% filter(index == ndx1)
# 		rho2 <- closestGeneOverall.df.lookup %>% filter(index == ndx2)
# 		
# 		geneList1 <- closestGeneOverall.df.catByDist %>% filter(group == rho1$group, experimental==rho1$experimental, pile == rho1$pile, category == rho1$category) %>% select(flybase) %>% unique()
# 		geneList2 <- closestGeneOverall.df.catByDist %>% filter(group == rho2$group, experimental==rho2$experimental, pile == rho2$pile, category == rho2$category) %>% select(flybase) %>% unique()
# 
# 		closestGeneOverall.df.sharedGeneFrac <- rbind(closestGeneOverall.df.sharedGeneFrac, cbind(ndx1, ndx2, nrow(geneList1), nrow(geneList2), nrow(intersect(geneList1,geneList2))))		
# 		print(c(ndx1,ndx2))
# 	}
# 	
# 	
# }
# 


```

When two sets of peaks are compared to the gene annotation, two gene lists are created. The similarity of the peak sets can be compared by examining the fraction of shared items between the two lists. 

### Closest Feature Overall

For each peak, the closest gene (upstream or down) was identified. These were further divided into categories based on the magnitude of the distance:
```
I: < 100bp
II: 100 - 1000 bp
III: 1kb - 20kb
IV: > 20kb
```

The gene lists thus generated were compared round-robin and their similarity calculated. (Group C has been omitted from these heat maps)


```{r echo=FALSE}

closestFeat_geneLists.sim.byDist <- read_delim("features/genelists/closestFeatOverall.geneLists.similarities.byDist", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(closestFeat_geneLists.sim.byDist) <- c("experimental1", "pile1", "group1", "listType", "annot1", "dist_cat1", "experimental2", "pile2", "group2", "drop1", "annot2" , "dist_cat2", "count1", "count2", "shared", "drop2" )
closestFeat_geneLists.sim.byDist <- closestFeat_geneLists.sim.byDist%>% mutate(similarity = 2*shared/(count1+count2), list1 = paste(experimental1, pile1, group1, dist_cat1, sep="_" ), list2 = paste(experimental2, pile2, group2, dist_cat2, sep="_" ), dist_cat=dist_cat1) %>% select(-c(drop1, drop2, annot1, annot2, dist_cat1, dist_cat2)) 


#closestFeat_geneLists.overlaps <- read_delim("features/genelists/closestFeat.geneLists.overlap", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
#names(closestFeat_geneLists.overlaps) <- c("experimental1", "pile1", "group1", "listType", "experimental2", "pile2", "group2", "drop1", "dist_cat", "count1", "count2", "shared", "drop2" )
#closestFeat_geneLists.overlaps <- closestFeat_geneLists.overlaps %>% select(-c(drop1, drop2)) %>% mutate(similarity = 2*shared/(count1+count2), list1 = paste(experimental1, pile1, group1, dist_cat, sep="_" ), list2 = paste(experimental2, pile2, group2, dist_cat, sep="_" ))

```

```{r echo=FALSE}

ggplot(closestFeat_geneLists.sim.byDist %>% filter(dist_cat == "I") %>% filter(group1 != "C")  %>% filter( group2 != "C")) + geom_tile(aes(list1, list2, fill=similarity)) + scale_fill_gradient(low = "black",high = "white", limits=c(0,1))+ new_scale_fill() + scale_fill_discrete() + geom_tile(aes(list1, list2, fill=experimental1), alpha=0.25) + labs(x="", y="", title= "Similarity Between Lists of Genes Closest to Peaks\nDistance Category I: < 100bp")+ theme_bw()+ theme(axis.text.x = element_text(angle = -45, hjust = 0))  

#ggplot(closestFeat_geneLists.overlaps %>% filter(dist_cat == "I") %>% filter(group1 != "C")  %>% filter( group2 != "C")) + geom_tile(aes(list1, list2, fill=similarity)) + scale_fill_gradient(low = "black",high = "white", limits=c(0,1))+ new_scale_fill() + scale_fill_discrete() + geom_tile(aes(list1, list2, fill=experimental1), alpha=0.25) + labs(x="", y="", title= "Similarity Between Lists of Genes Closest to Peaks\nDistance Category I: < 100bp")+ theme_bw()+ theme(axis.text.x = element_text(angle = -45, hjust = 0))  
```

```{r echo=FALSE}
ggplot(closestFeat_geneLists.sim.byDist %>% filter(dist_cat == "II") %>% filter(group1 != "C")  %>% filter( group2 != "C")) + geom_tile(aes(list1, list2, fill=similarity)) + scale_fill_gradient(low = "black",high = "white", limits=c(0,1))+ new_scale_fill() + scale_fill_discrete() + geom_tile(aes(list1, list2, fill=experimental1), alpha=0.25) + labs(x="", y="", title= "Similarity Between Lists of Genes Closest to Peaks\nDistance Category II: 100 - 1000 bp
")+ theme_bw()+ theme(axis.text.x = element_text(angle = -45, hjust = 0))  
```

```{r echo=FALSE}
ggplot(closestFeat_geneLists.sim.byDist %>% filter(dist_cat == "III") %>% filter(group1 != "C")  %>% filter( group2 != "C")) + geom_tile(aes(list1, list2, fill=similarity)) + scale_fill_gradient(low = "black",high = "white", limits=c(0,1))+ new_scale_fill() + scale_fill_discrete() + geom_tile(aes(list1, list2, fill=experimental1), alpha=0.25) + labs(x="", y="", title= "Similarity Between Lists of Genes Closest to Peaks\nDistance Category III: 1kb - 20kb")+ theme_bw()+ theme(axis.text.x = element_text(angle = -45, hjust = 0))  
```

```{r echo=FALSE}
ggplot(closestFeat_geneLists.sim.byDist %>% filter(dist_cat == "IV") %>% filter(group1 != "C")  %>% filter( group2 != "C")) + geom_tile(aes(list1, list2, fill=similarity)) + scale_fill_gradient(low = "black",high = "white", limits=c(0,1))+ new_scale_fill() + scale_fill_discrete() + geom_tile(aes(list1, list2, fill=experimental1), alpha=0.25) + labs(x="", y="", title= "Similarity Between Lists of Genes Closest to Peaks\nDistance Category IV: > 20kb")+ theme_bw()+ theme(axis.text.x = element_text(angle = -45, hjust = 0))  
```






## Gene Ontology
```{r echo=FALSE}
# ####	note: pull a lot of this out into a stand-alone script!
#BiocManager::install("org.Dm.eg.db")
# library("topGO")
# 
# 
# ensembl_dm = useMart("ensembl",dataset="dmelanogaster_gene_ensembl")
# # ensembl_dm = useMart("ensembl",dataset="dmelanogaster_gene_ensembl", host = "useast.ensembl.org")
# # #marty <- useDataset("hsapiens_gene_ensembl", useMart("ensembl"))
marty <- useDataset("dmelanogaster_gene_ensembl",  useMart("ensembl",  host = "useast.ensembl.org") )
# 
G_list <- getBM(attributes= c("flybase_gene_id", "ensembl_gene_id", "entrezgene_id", "go_id", "name_1006", "definition_1006"), mart= marty) 
# 
# ### plz fix this
# go_bad <- c("GO:0110109","GO:0120176","GO:0120177","GO:0120170","GO:0062023")
# bad_boiz <- G_list %>% filter(go_id %in% go_bad) %>% dplyr::select("flybase_gene_id")
# bad_boiz <- rbind(bad_boiz, "FBgn0050046", "FBgn0033710",  "FBgn0050203", "FBgn0026721")
# G_list.unq <- G_list %>% filter(!flybase_gene_id %in% bad_boiz$flybase_gene_id ) %>% dplyr::select("flybase_gene_id") %>% unique()
# 
# 
# closestGenesOverall.fb <- closestGeneOverall.df %>%  filter(stream=="up" & group=="A" & pile=="input_exclusive" & experimental == "Fru7") %>% dplyr::select(flybase) %>% unique() %>% as.list()
# 
# 
# jeanOnt.df <- as.data.frame(c())
# 
# for (ont in c("MF","BP","CC") ){
# 	
# 	gene_list <- factor(as.integer( G_list.unq$flybase_gene_id %in% closestGenesOverall.fb$flybase))
# 	names(gene_list) <- G_list.unq$flybase_gene_id
# 	
# 	GOdata <- new("topGOdata", ontology = ont, allGenes = gene_list, annot = annFUN.org, mapping = "org.Dm.eg.db", ID="Ensembl")
# 
# 	fishy <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
# 	goRes.tmp <- GenTable(GOdata, classicFisher =fishy, ranksOf = "classicFisher", topNodes = 10)
# 	goRes.tmp$ontology <- ont
# 
# 	jeanOnt.df <- rbind(jeanOnt.df, goRes.tmp)	
# }
# 

```

Gene ontology enrichment analysis was performed using topGO and Ensembl data by way of BioMart. Analyses were done on lists of the closest genes upstream and downstream of various collections of peaks, organized by experimental treatment, input/output/shared pile, group, and distance category. The top 10 most significant GO terms for each such list were collected.

```{r echo=FALSE}
closestUpstream.dm6_genes.go <- read_delim("features/ontologies/closestUpstreamFeat.dm6_genes.go", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(closestUpstream.dm6_genes.go) <- c("experimental", "pile", "group", "stream", "distcat", "go_id", "go_term", "annotated", "num_significant", "num_expected", "p", "ontology")

closestUpstream.dm6_genes.go <- inner_join(closestUpstream.dm6_genes.go %>% dplyr::select(-c(go_term)) %>%  mutate(experimental = as.factor(experimental), pile= as.factor(pile), group = as.factor(group), stream = as.factor(stream), distcat = as.factor(distcat),ontology = as.factor(ontology)), G_list %>% dplyr::select("go_id", "name_1006") %>% unique(), by=c("go_id"="go_id")) %>% mutate(go_id = as.factor(go_id)) %>% rename("GO_term" = name_1006 )

closestUpstream.dm6_genes.go.top10 <- closestUpstream.dm6_genes.go %>% group_by(experimental, pile, group, stream, distcat) %>% top_n(n=10, wt = -p) 


ggplot(closestUpstream.dm6_genes.go.top10, aes(x=experimental, y=-log10(p), color=ontology, shape=group)) + geom_point() + geom_jitter(width=0.25) + facet_grid(distcat ~ pile) + theme_bw() + labs(y="Significance (pp) ", title= "Top 10 GO Enrichment for Genes Upstream of Peaks")


```



```{r echo=FALSE}
closestDownstream.dm6_genes.go <- read_delim("features/ontologies/closestDownstreamFeat.dm6_genes.go", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(closestDownstream.dm6_genes.go) <- c("experimental", "pile", "group", "stream", "distcat", "go_id", "go_term", "annotated", "num_significant", "num_expected", "p", "ontology")

closestDownstream.dm6_genes.go <- inner_join(closestDownstream.dm6_genes.go %>% dplyr::select(-c(go_term)) %>%  mutate(experimental = as.factor(experimental), pile= as.factor(pile), group = as.factor(group), stream = as.factor(stream), distcat = as.factor(distcat),ontology = as.factor(ontology)), G_list %>% dplyr::select("go_id", "name_1006") %>% unique(), by=c("go_id"="go_id")) %>% mutate(go_id = as.factor(go_id)) %>% rename( "GO_term" = name_1006)

closestDownstream.dm6_genes.go.top10 <- closestDownstream.dm6_genes.go %>% group_by(experimental, pile, group, stream, distcat) %>% top_n(n=10, wt = -p) 


ggplot(closestDownstream.dm6_genes.go.top10, aes(x=experimental, y=-log10(p), ))   + geom_jitter(aes(color=ontology, shape=group), width=0.25)+ geom_boxplot(aes(group=experimental), alpha=0.5) + facet_grid(distcat ~ pile) + theme_bw() + labs(y="Significance (pp) ", title= "Top 10 GO Enrichment for Genes Downstream of Peaks")


```

```{r echo=FALSE}
closestOverall.dm6_genes.go <- read_delim("features/ontologies/closestFeatOverall.dm6_genes.go", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(closestOverall.dm6_genes.go) <- c("experimental", "pile", "group", "stream", "distcat", "go_id", "go_term", "annotated", "num_significant", "num_expected", "p", "ontology")

closestOverall.dm6_genes.go <- inner_join(closestOverall.dm6_genes.go %>% dplyr::select(-c(go_term)) %>%  mutate(experimental = as.factor(experimental), pile= as.factor(pile), group = as.factor(group), stream = as.factor(stream), distcat = as.factor(distcat),ontology = as.factor(ontology), p=as.numeric(p)), G_list %>% dplyr::select("go_id", "name_1006") %>% unique(), by=c("go_id"="go_id")) %>% mutate(go_id = as.factor(go_id)) %>% rename( "GO_term" = name_1006)

closestOverall.dm6_genes.go.top10 <- closestOverall.dm6_genes.go %>% group_by(experimental, pile, group, stream, distcat) %>% top_n(n=10, wt = -p) 


ggplot(closestOverall.dm6_genes.go.top10, aes(x=experimental, y=-log10(p), ))   + geom_jitter(aes(color=ontology, shape=group), width=0.25)+ geom_boxplot(aes(group=experimental), alpha=0.5) + facet_grid(distcat ~ pile) + theme_bw() + labs(y="Significance (pp) ", title= "Top 10 GO Enrichment for Closest Genes Overall")


```

Two obvious patterns: The most extreme distance categories have the least significant enrichment (there are some exceptions in category I, output exclusive, downstream genes), and enrichment in downstream gene lists tends to be much more significant than in upstream gene lists. 

Focussing on the downstream genes and group A, here are the top 10 enriched GO terms by experimental treatment and distance category:

```{r echo=FALSE}

closestDownstream.dm6_genes.go.top10 %>% ungroup() %>% filter(pile == "output_exclusive" & group =="A" & experimental == "Fru7") %>% select( go_id, GO_term,ontology, distcat, p,  ) %>% mutate(GO_term = substr(GO_term, 1,50)) %>% group_by(distcat) %>% arrange(p) %>% gt() %>% tab_header(title="Top 10 Significantly Enriched GO Terms", subtitle="Fru7, group A, by distance category") %>% cols_label(GO_term = "Description", go_id = "ID", ontology= "type")

```
%>% mutate(GO_term = paste(strsplit(GO_term, "(?<=.{10})", perl = TRUE)[[1]], collapse="\n"))

```{r echo=FALSE}

closestDownstream.dm6_genes.go.top10 %>% ungroup() %>% filter(pile == "output_exclusive" & group =="A" & experimental == "47b1_7") %>% select( go_id, GO_term,ontology, distcat, p,  )%>% mutate(GO_term = substr(GO_term, 1,50)) %>% group_by(distcat)  %>% arrange(p) %>% gt() %>% tab_header(title="Top 10 Significantly Enriched GO Terms", subtitle="47b1-7, group A, by distance category") %>% cols_label(GO_term = "Description", go_id = "ID", ontology= "type")

```


```{r echo=FALSE}

closestDownstream.dm6_genes.go.top10 %>% ungroup() %>% filter(pile == "output_exclusive" & group =="A" & experimental == "GH7") %>% select( go_id, GO_term,ontology, distcat, p,  ) %>% mutate(GO_term = substr(GO_term, 1,50))%>% group_by(distcat) %>% arrange(p) %>% gt() %>% tab_header(title="Top 10 Significantly Enriched GO Terms", subtitle="GH7, group A, by distance category") %>% cols_label(GO_term = "Description", go_id = "ID", ontology= "type")

```


```{r echo=FALSE}

closestDownstream.dm6_genes.go.top10 %>% ungroup() %>% filter(pile == "output_exclusive" & group =="A" & experimental == "SH7") %>% select( go_id, GO_term,ontology, distcat, p,  )%>% mutate(GO_term = substr(GO_term, 1,50)) %>% group_by(distcat) %>% arrange(p) %>% gt() %>% tab_header(title="Top 10 Significantly Enriched GO Terms", subtitle="SH7, group A, by distance category") %>% cols_label(GO_term = "Description", go_id = "ID", ontology= "type")

```





```{r echo=FALSE}

#Top  Overall Significiant GO terms and Where They Were Found


bothStreams.dm6_genes.go <-  rbind(closestUpstream.dm6_genes.go, closestDownstream.dm6_genes.go)



hi_scores <- bothStreams.dm6_genes.go %>% arrange(p) %>% dplyr::select(go_id) %>% unique() %>% head(n=20)

bothStreams.dm6_genes.go.hiScore <- bothStreams.dm6_genes.go %>%  filter(go_id %in% hi_scores$go_id)

#bothStreams.dm6_genes.go.hiScore %>% group_by(GO_term) %>% summarise(count=n(), ann = max(annotated))




```


```{r echo=FALSE}


potato <- bothStreams.dm6_genes.go.hiScore %>% filter(group == "A") %>% select(-c(group, annotated, num_significant, num_expected )) %>% unite(lump, c(experimental, pile, stream, distcat), sep = " ") %>% mutate(significance = - log10(p)) %>% complete(lump, GO_term, fill = list(significance = 0))

ggplot(potato) + geom_tile(aes(lump, GO_term,  fill=significance)) + scale_fill_continuous(low="black", high = "white", name="significance (pp)") + theme(axis.text.x = element_text(angle = -45, hjust = 0)) + labs(title="Overall Most Significant GO Terms and their Distribution Across Samples", x = "gene list", y = "GO term" ) 

```

TODO: work on DAG visuals?
Use this but with PARENT() not ANCESTORS()
https://biology.stackexchange.com/questions/44887/get-parent-go-terms-of-go-term-vector


### Narrowing the GO terms

Some GO terms are subsets of others, meaning that some are very broad. 
TODO: work on this


```{r echo=FALSE}



ggplot(G_list %>%  group_by(go_id) %>%  summarise(count=n()) %>% arrange(desc(count))) + geom_histogram(aes(x=count)) + scale_x_log10()


hi_scores <- bothStreams.dm6_genes.go %>% filter(annotated < 250) %>% arrange(p) %>% dplyr::select(go_id) %>% unique() %>% head(n=10)

#bothStreams.dm6_genes.go.hiScore <- bothStreams.dm6_genes.go %>%  filter(go_id %in% hi_scores$go_id)

#bothStreams.dm6_genes.go.hiScore %>% group_by(GO_term) %>% summarise(count=n())

#bothStreams.dm6_genes.go.hiScore %>% group_by(GO_term, experimental, pile) %>% summarise(minSig=max(p)) %>% spread(experimental, minSig) 

```




## predefined genes of interest : ionotropic receptor genes

As well as using peaks to identify genes of interest, predefined gene lists can also be checked against the peaks to test their association. For now, let's look at the ionotropic [SIC] receptor gene list (section 2.7.1)

### Overlapping

```{r echo=FALSE, warning=FALSE, message=FALSE}
collapsed_intersect_ionotropic <- read_delim("meta/vs_dm6.bwa.collapsed.intersect.ionotropic.full.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(collapsed_intersect_ionotropic) <- c("partition", "experimental", "group", "measure", "type", "value")
collapsed_intersect_ionotropic$partition <- as.factor(collapsed_intersect_ionotropic$partition)
collapsed_intersect_ionotropic$experimental <- as.factor(collapsed_intersect_ionotropic$experimental)
collapsed_intersect_ionotropic$group <- as.factor(collapsed_intersect_ionotropic$group)
collapsed_intersect_ionotropic$measure <- as.factor(collapsed_intersect_ionotropic$measure)
collapsed_intersect_ionotropic$type <- as.factor(collapsed_intersect_ionotropic$type)
```


Peaks overlapping a subset can be tallied in the same manner as the full annotation (3.1.3):
(How to un-skew this comparison??????????)

```{r echo=FALSE, warning=FALSE, message=FALSE}

collapsed_intersect_ionotropic %>% unite(measure, type, sep="_", col=megameasure) %>% unite(partition, group, sep="_", col=supergroup) %>% mutate(megameasure=recode(megameasure, "count_uniqA"="number peaks overlapping", "count_uniqB"="number genes overlapped", "avg_AperB"="mean peaks per gene","avg_BperA"="mean genes per peak","max_AperB"="max peaks per gene","max_BperA"="max genes per peak")) %>% spread(supergroup, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt() %>% fmt_number(columns = seq(2,10), suffixing=T, decimals=1) %>% fmt_number(columns = seq(2,10), rows=starts_with("max", vars=c(megameasure)) , suffixing=T, decimals=0) %>%fmt_number(columns = seq(2,10), rows=starts_with("number", vars=c(megameasure)) , suffixing=T, decimals=0) %>% tab_spanner(label="exclusive to input", columns=starts_with("input_"))%>% tab_spanner(label="exclusive to output", columns=starts_with("output_")) %>% tab_spanner(label="shared", columns=starts_with("shared_")) %>% cols_label(input_exclusive_A="A",input_exclusive_B="B",input_exclusive_C="C",output_exclusive_A="A",output_exclusive_B="B",output_exclusive_C="C", shared_A="A",shared_B="B",shared_C="C",	megameasure="")

```

These counts can be compared to those we'd predict based on the count fraction or the length fraction of the subset compared to the full annotation:

```{r echo=FALSE, warning=FALSE, message=FALSE}



gene_overlap_expect <- collapsed_intersect_dm6_genes_full %>% unite(measure, type, sep="_", col=megameasure) %>% unite(partition, group, sep="_", col=supergroup) %>% filter(megameasure == "count_uniqB") %>% mutate(expected = value * (geneList.tbl %>% filter(query == "ionotropic" & measure == "percent annotation size") %>% select(value) %>% as.numeric()) ) 

peak_overlap_expect <- collapsed_intersect_dm6_genes_full %>% unite(measure, type, sep="_", col=megameasure) %>% unite(partition, group, sep="_", col=supergroup) %>% filter(megameasure == "count_uniqA") %>% mutate(expected = value * (geneList.tbl %>% filter(query == "ionotropic" & measure == "percent genome size") %>% select(value) %>% as.numeric()) ) 

```

```{r echo=FALSE}

inner_join(rbind(gene_overlap_expect, peak_overlap_expect) %>% select(-c(value)), collapsed_intersect_ionotropic %>% filter(measure=="count") %>% unite(measure, type, sep="_", col=megameasure) %>% filter(megameasure == "count_uniqA" | megameasure == "count_uniqB") %>% unite(partition, group, sep="_", col=supergroup), by= c("megameasure" = "megameasure", "supergroup"= "supergroup", "experimental" ="experimental")) %>% mutate(megameasure=recode(megameasure, "count_uniqA"="number peaks overlapping", "count_uniqB"="number genes overlapped")  ) %>% rename( "observed"="value") %>% gather(expected, observed, key = comp,  value=value) %>%  unite(comp, megameasure, sep=" ", col=measure)  %>% spread(supergroup, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt() %>% tab_spanner(label="exclusive to output", columns=starts_with("output_")) %>%  tab_spanner(label="exclusive to input", columns=starts_with("input_")) %>% tab_spanner(label="shared", columns=starts_with("shared_")) %>% cols_label(input_exclusive_A="A", input_exclusive_B="B", input_exclusive_C="C",output_exclusive_A="A",output_exclusive_B="B",output_exclusive_C="C", shared_A="A",shared_B="B",shared_C="C",	measure="") %>% fmt_number(columns = seq(2,10),rows=str_detect(measure, "observed"), suffixing=T, decimals=0) %>% fmt_number(columns = seq(2,10),rows=str_detect(measure, "expected"), suffixing=T, decimals=1)



```



Here is the distribution of overlap counts, compared to the full gene set (filtered to remove high-peak count outliers)

```{r echo=FALSE}


total_iono_count <- geneLists.stats %>% filter(query=="ionotropic" & measure=="count" & type == "annotated") %>% select(value) %>% as.integer()

peaksPerGene.iono.hist.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
		for (grup in c("A", "B", "C")) {
			for ( pile in c("shared","output_exclusive","input_exclusive") ){
				tmp.df <- read_delim(paste("features/intersects/",gsub("-", "_", nom),".vs_dm6.bwa.",pile,".group_",grup,".collapsed.intersect.ionotropic.byGenePeaks.count", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)

				names(tmp.df) <- c("V1", "V2")
				num_zed <- total_iono_count - nrow(tmp.df)
				tmp.df <- rbind(tmp.df, cbind(rep("potato", num_zed), rep(0, num_zed) ))
				names(tmp.df) <- c("geneId", "peakCount")
				tmp.df$experimental <- as.factor(nom)
				tmp.df$group <- as.factor(grup)
				tmp.df$pile <- as.factor(pile)


				peaksPerGene.iono.hist.df <- rbind(peaksPerGene.iono.hist.df, tmp.df)
			}
	}
}
peaksPerGene.iono.hist.df$peakCount <- as.integer(peaksPerGene.iono.hist.df$peakCount)





ggplot(peaksPerGene.hist.df %>% filter(peakCount<25)) + geom_freqpoly(aes(x=peakCount, color=group, stat(density)), bins=25, linetype="dashed") + geom_freqpoly(data = peaksPerGene.iono.hist.df, aes(x=peakCount, color=group, stat(density)), bins=25, linetype = "solid") + facet_grid(experimental ~ pile) + labs(x= "# peaks per gene", y="count", title="Distribution of Peaks per Gene (Ionotropic with Background)")

#+ scale_x_continuous(trans=pseudo_log_trans(base=10), breaks=c(1,10,100,10000), labels = trans_format("log10", math_format(10^.x))) + scale_y_log10() + labs(x= "# peaks per gene", y="count", title="Distribution of Peaks per Gene")


```




Additionally, randomized peaks can be used to estimate the background overlapping rate:


```{r echo=FALSE}

scrambledPeaks_intersectWithAnnotations <- read_delim("meta/scrambledPeaks_intersectWithAnnots.counts",  "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) 

names(scrambledPeaks_intersectWithAnnotations) <- c("annotation", "pile", "experimental", "group", "scram", "count")
scrambledPeaks_intersectWithAnnotations$annotation <-as.factor(scrambledPeaks_intersectWithAnnotations$annotation)
scrambledPeaks_intersectWithAnnotations$pile <-as.factor(scrambledPeaks_intersectWithAnnotations$pile)
scrambledPeaks_intersectWithAnnotations$experimental <-as.factor(scrambledPeaks_intersectWithAnnotations$experimental)
scrambledPeaks_intersectWithAnnotations$group <-as.factor(scrambledPeaks_intersectWithAnnotations$group)


scrambledPeaks_intersectWithIonotropic <- scrambledPeaks_intersectWithAnnotations %>%  filter(annotation == "ionotropic")
scrambledPeaks_intersectWithIonotropic.stats <- scrambledPeaks_intersectWithIonotropic %>% group_by(annotation,pile,experimental,group) %>% summarise(avg = mean(count), std = sd(count))



intersectWithIonotropic.scrambledVnot <- rbind(scrambledPeaks_intersectWithIonotropic.stats %>% ungroup() %>% rename( "partition" = "pile", "count" = "avg" ,"unc"="std" ) %>% mutate(empirical=as.factor("scrambled")) %>% dplyr::select(c(partition, experimental, group, count, unc, empirical)) , collapsed_intersect_ionotropic %>% unite(measure, type, sep="_", col=megameasure) %>% filter(megameasure == "count_uniqB" ) %>% rename("count"="value") %>% mutate(unc=NA, empirical=as.factor("measured")) %>% dplyr::select(-c(megameasure)) )

#intersectWithIonotropic.scrambledVnot <- rbind(scrambledPeaks_intersectWithIonotropic.stats %>% ungroup() %>% rename( "partition" = "pile", "count" = "avg" ,"unc"="std" ) %>% mutate(empirical=as.factor("scrambled")) %>% dplyr::select(c(partition, experimental, group, count, unc, empirical)) , collapsed_intersect_ionotropic %>% unite(measure, type, sep="_", col=megameasure) %>% filter(megameasure == "count_uniqB" ) %>% rename("value"="count") %>% mutate(unc=NA, empirical=as.factor("measured")) %>% dplyr::select(-c(megameasure)) )


intersectWithIonotropic.scrambledVnot %>% gather(key="measure", value="value", count, unc) %>% unite(partition, group, measure,  sep="_", col=supergroup) %>% spread(supergroup, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental)), empirical=recode(empirical, "measured"="observed", "scrambled"="scrambled")) %>% group_by(experimental) %>% gt() %>% fmt_number(columns = ends_with("count"), rows = empirical == "observed", decimals = 0) %>% fmt_number(columns = ends_with("count"), rows = empirical == "scrambled", decimals = 1)%>% fmt_number(columns = ends_with("unc"), rows = empirical == "scrambled", decimals = 1)  %>% cols_merge_uncert(col_val='input_exclusive_A_count', 'input_exclusive_A_unc')  %>% cols_merge_uncert(col_val='output_exclusive_A_count', 'output_exclusive_A_unc')  %>% cols_merge_uncert(col_val='shared_A_count', 'shared_A_unc')  %>% cols_merge_uncert(col_val='input_exclusive_B_count', 'input_exclusive_B_unc')  %>% cols_merge_uncert(col_val='output_exclusive_B_count', 'output_exclusive_B_unc')  %>% cols_merge_uncert(col_val='shared_B_count', 'shared_B_unc')  %>% cols_merge_uncert(col_val='input_exclusive_C_count', 'input_exclusive_C_unc')  %>% cols_merge_uncert(col_val='output_exclusive_C_count', 'output_exclusive_C_unc')  %>% cols_merge_uncert(col_val='shared_C_count', 'shared_C_unc') %>% tab_spanner(label="exclusive to output", columns=starts_with("output_")) %>%  tab_spanner(label="exclusive to input", columns=starts_with("input_")) %>% tab_spanner(label="shared", columns=starts_with("shared_"))%>% cols_label(input_exclusive_A_count="A", input_exclusive_B_count="B", input_exclusive_C_count="C",output_exclusive_A_count="A",output_exclusive_B_count="B",output_exclusive_C_count="C", shared_A_count="A",shared_B_count="B",shared_C_count="C", empirical="")


```


In all prediction schemes, this subset appears to have fewer overlapped genes and fewer overlapping peaks than expected. 



```{r echo=FALSE, message=FALSE}
# 
# peakCountsByAnn_ionotrop <- read_delim("/proj/cdjones_lab/csoeder/volkan_faire/features/intersects/peakCountsByAnn.ionotropic.tbl", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
# names(peakCountsByAnn_ionotrop) <- c("experimental","pile","group","gene","count")
# peakCountsByAnn_ionotrop <- peakCountsByAnn_ionotrop %>% mutate(experimental = as.factor(experimental),pile = as.factor(pile), group = as.factor(group), gene = as.factor(gene)) %>% as_tibble()
# 
# peakCountsByAnn_ionotrop <- peakCountsByAnn_ionotrop %>% spread(pile,count) %>% arrange(gene, experimental, group) %>% select(c(gene, experimental, group, input_exclusive, output_exclusive, shared)) %>%  mutate_all(~replace(., is.na(.), 0))
# 
# write_delim(peakCountsByAnn_ionotrop, "peakCountsByAnn.ionotropic.tbl", delim = "\t")


```


### Adjacent

Proximity to the subset can also be investigated as with the full annotation.

```{r echo=FALSE, message=FALSE}


closestPeaks.streamed.ionotropic.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental %>% unique() ) {
		for (grup in c("A", "B", "C")) {
			for ( pile in c("shared","output_exclusive","input_exclusive") ){
				for (stream in c("Upstream", "Downstream") ) {
					tmp.df <- read_delim(paste("features/closest/ionotropic.closest",stream,"Peak.",gsub("-", "_", nom),".vs_dm6.bwa.",pile,".group_",grup,".collapsed.full.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)
				names(tmp.df) <- c("gene_chrom", "gene_start", "gene_stop", "flybase","score", "strand", "gene_name","peak_chrom", "peak_start", "peak_stop", "distance")
				tmp.df <- tmp.df %>% dplyr::select(-c(score))# %>% filter(distance !=0)
				tmp.df$peak_chrom <- as.factor(tmp.df$peak_chrom)
				tmp.df$gene_chrom <- as.factor(tmp.df$gene_chrom)
				tmp.df$flybase <- as.factor(tmp.df$flybase)
				tmp.df$gene_name <- as.factor(tmp.df$gene_name)
				tmp.df$experimental <- as.factor(nom)
				tmp.df$group <- as.factor(grup)
				tmp.df$pile <- as.factor(pile)
				tmp.df$stream <- as.factor(stream)
				
				closestPeaks.streamed.ionotropic.df <- rbind(closestPeaks.streamed.ionotropic.df, tmp.df)
				}#ionotropic.closestDownstreamPeak.Fru7.vs_dm6.bwa.output_exclusive.group_C.collapsed.full.bed
			}
	}
}

```


```{r echo=FALSE,}

ggplot(closestPeaks.streamed.ionotropic.df) + geom_freqpoly(aes(x=abs(distance), color=experimental, linetype=stream )) + facet_grid(group~pile) + scale_x_log10() + scale_y_log10() + ggbio::theme_clear()


```



```{r echo=FALSE, message=FALSE}

closestPeaks.streamed.ionotropic.scrambled.df <-as.data.frame(c()) 
closestPeaks.streamed.ionotropic.scrambled.summary.df <-as.data.frame(c()) 

for (nom in data_sets.df.sparse$experimental %>% unique()) {
	for (grup in c("A", "B", "C")) {
			for ( pile in c("shared","output_exclusive","input_exclusive") ){
				for (stream in c("Upstream", "Downstream") ) {
					tmp.df <- read_delim(paste("features/scrambled/closest/ionotropic.closest",stream,"Peak.",gsub("-", "_", nom),".vs_dm6.bwa.",pile,".group_",grup,".collapsed.full.scrmbl.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)
					scrm_num <- length(tmp.df %>% names()) - 7

					names(tmp.df) <- c("chrom", "start", "stop", "flybase", "score", "strand", "gene_name", seq(1,scrm_num))
					tmp.df <- tmp.df %>% select(-c(score))
					
					tmp.df.gath <- tmp.df %>% gather(key=scrm, value=dist, as.character(seq(1,scrm_num)) ) 
					tmp.df.sum <- tmp.df.gath %>% group_by(flybase, gene_name) %>% summarise(avg_dist = mean(dist), std_dist = sd(dist)) %>% ungroup()
					
					
					tmp.df.gath$experimental <- as.factor(nom)
					tmp.df.gath$group <- as.factor(grup)
					tmp.df.gath$pile <- as.factor(pile)
					tmp.df.gath$stream <- as.factor(stream)
					
					tmp.df.sum$experimental <- as.factor(nom)
					tmp.df.sum$group <- as.factor(grup)
					tmp.df.sum$pile <- as.factor(pile)
					tmp.df.sum$stream <- as.factor(stream)
					
					#names(closestPeaks.streamed.ionotropic.scrambled.df) <- names(tmp.df.gath)
					closestPeaks.streamed.ionotropic.scrambled.df <- rbind(closestPeaks.streamed.ionotropic.scrambled.df , tmp.df.gath)
					closestPeaks.streamed.ionotropic.scrambled.summary.df <- rbind(closestPeaks.streamed.ionotropic.scrambled.summary.df, tmp.df.sum)
			}
		}
	}
}

					#tmp.df.gath$flybase <- as.factor(tmp.df.gath$flybase)
					#tmp.df.gath$gene_name <- as.factor(tmp.df.gath$gene_name)


```


Randomized peaks can be used to create a background proximity distribution. For example, the distance histogram for five scramblings of the GH7 group A input_exclusive peaks are shown (blue envelope), as well as the observed distribution (red)

```{r echo=FALSE}

bigBin <- max(closestPeaks.streamed.ionotropic.scrambled.df %>% filter(experimental == "GH7" & group == "A" & pile == "input_exclusive") %>% select(dist), closestPeaks.streamed.ionotropic.df %>% filter(experimental == "GH7" & group == "A" & pile == "input_exclusive") %>% select(distance) )
bins <- exp(seq(0,log(ceiling(bigBin)),0.5))

gpb <- ggplot_build(  ggplot(closestPeaks.streamed.ionotropic.scrambled.df %>% filter(experimental == "GH7" & group == "A" & pile == "input_exclusive")) + geom_freqpoly(aes(x=abs(dist), group = scrm), breaks=bins) )

gpb_rib <- gpb$data[[1]] %>% group_by(x) %>% summarise(mack = max(count), minn = min(count))

ggplot() + geom_freqpoly(data = closestPeaks.streamed.ionotropic.scrambled.df %>% filter(experimental == "GH7" & group == "A" & pile == "input_exclusive"), aes(x=abs(dist), group = scrm), color='black', alpha=0.25, breaks=bins ) + geom_freqpoly(data=closestPeaks.streamed.ionotropic.df %>% filter(experimental == "GH7" & group == "A" & pile == "input_exclusive"), aes(x=abs(distance), color=experimental), breaks=bins) + geom_ribbon(data=gpb_rib, aes(x=x, ymax=mack, ymin=minn), fill="blue", alpha=0.25) + scale_x_log10() + ggbio::theme_clear()

```

```{r echo=FALSE}


bigBin <- max(closestPeaks.streamed.ionotropic.scrambled.df$dist, closestPeaks.streamed.ionotropic.df$distance )
bins <- exp(seq(0,log(ceiling(bigBin)),0.5))


gpb_rib <- as.data.frame(c())
for (nom in data_sets.df.sparse$experimental %>% unique()) {
	for (grup in c("A", "B", "C")) {
			for ( pyle in c("shared","output_exclusive","input_exclusive") ){
				for (streem in c("Upstream", "Downstream") ) {
					gpb <- ggplot_build(  ggplot(closestPeaks.streamed.ionotropic.scrambled.df %>% filter(experimental == nom & group == grup & pile == pyle & stream == streem)) + geom_freqpoly(aes(x=abs(dist), group = scrm), breaks=bins) )
					gpb_rib.tmp <- gpb$data[[1]] %>% group_by(x) %>% summarise(mack = max(count), minn = min(count))
					gpb_rib.tmp$experimental <- as.factor(nom)
					gpb_rib.tmp$group <- as.factor(grup)
					gpb_rib.tmp$pile <- as.factor(pyle)
					gpb_rib.tmp$stream <- as.factor(streem)
					
					gpb_rib <- rbind(gpb_rib, gpb_rib.tmp)
				}
			}
		}
	}

ggplot() +  geom_ribbon(data=gpb_rib, aes(x=x, ymax=mack, ymin=minn, linetype=stream,fill=experimental),  alpha=0.25) + geom_freqpoly(data=closestPeaks.streamed.ionotropic.df, aes(x=abs(distance), color=experimental, linetype=stream), breaks=bins)  + scale_x_log10() + facet_grid(group~pile) + ggbio::theme_clear()



```


When all samples are considered, the shared peaks appear to be skewed to farther distances, compared to the background distribution:

```{r echo=FALSE}

inner_join(closestPeaks.streamed.ionotropic.df, closestPeaks.streamed.ionotropic.scrambled.summary.df) %>% mutate(dist_rat = log10(distance/avg_dist)) %>% ggplot() + geom_freqpoly(aes(x=dist_rat, color=experimental, linetype = stream)) + geom_vline(xintercept = 0) + facet_grid(group~pile) + ggbio::theme_clear()
```


## predefined genes of interest : GO categories

Other gene lists were drawn from GO categories. 

### Nervous system development



```{r echo=FALSE}

collapsed_intersect_NervSysDev <- read_delim("meta/vs_dm6.bwa.collapsed.intersect.nervSysDev.full.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(collapsed_intersect_NervSysDev) <- c("partition", "experimental", "group", "measure", "type", "value")
collapsed_intersect_NervSysDev$partition <- as.factor(collapsed_intersect_NervSysDev$partition)
collapsed_intersect_NervSysDev$experimental <- as.factor(collapsed_intersect_NervSysDev$experimental)
collapsed_intersect_NervSysDev$group <- as.factor(collapsed_intersect_NervSysDev$group)
collapsed_intersect_NervSysDev$measure <- as.factor(collapsed_intersect_NervSysDev$measure)
collapsed_intersect_NervSysDev$type <- as.factor(collapsed_intersect_NervSysDev$type)

```

```{r echo=FALSE}

collapsed_intersect_NervSysDev %>% unite(measure, type, sep="_", col=megameasure) %>% unite(partition, group, sep="_", col=supergroup) %>% mutate(megameasure=recode(megameasure, "count_uniqA"="number peaks overlapping", "count_uniqB"="number genes overlapped", "avg_AperB"="mean peaks per gene","avg_BperA"="mean genes per peak","max_AperB"="max peaks per gene","max_BperA"="max genes per peak")) %>% spread(supergroup, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt() %>% fmt_number(columns = seq(2,10), suffixing=T, decimals=1) %>% fmt_number(columns = seq(2,10), rows=starts_with("max", vars=c(megameasure)) , suffixing=T, decimals=0) %>%fmt_number(columns = seq(2,10), rows=starts_with("number", vars=c(megameasure)) , suffixing=T, decimals=0) %>% tab_spanner(label="exclusive to input", columns=starts_with("input_"))%>% tab_spanner(label="exclusive to output", columns=starts_with("output_")) %>% tab_spanner(label="shared", columns=starts_with("shared_")) %>% cols_label(input_exclusive_A="A",input_exclusive_B="B",input_exclusive_C="C",output_exclusive_A="A",output_exclusive_B="B",output_exclusive_C="C", shared_A="A",shared_B="B",shared_C="C",	megameasure="")

```

## GH vs SH 

Not only interested in results within experimental treatments, but between them. 


### Compare & Contrast Peaks 


asdfasdf



### Peak Distances

sdfasdlfjasldkfjal;ksdjfa;lksdjflkasdjflaksdjfsdfj

### Gene List Similarity
```{r echo=FALSE}

closestDownstreamFeat_geneLists <- read_delim("features/genelists/similarities/closestDownstreamFeat.geneLists.similarities", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(closestDownstreamFeat_geneLists) <- c("experimental1", "pile1", "group1", "drop1","annot1","dist_cat1","experimental2", "pile2", "group2", "drop2","annot2","dist_cat2","count1", "count2", "shared", "drop3" )
closestDownstreamFeat_geneLists <- closestDownstreamFeat_geneLists %>% select(-c(drop1, drop2, drop3, annot1, annot2)) %>% filter(experimental1 == "GH7" & experimental2 == "SH7") %>% filter(group1 != "C" & group2 != "C") %>% filter(pile1 =="output_exclusive" & pile1==pile2) %>% mutate(similarity = 2*shared/(count1+count2), list1 = paste(experimental1, group1, dist_cat1, sep="_" ), list2 = paste(experimental2, group2, dist_cat2, sep="_" ))

ggplot(closestDownstreamFeat_geneLists) + geom_tile(aes(list1, list2, fill=similarity))+ labs(x="", y="", title= "Similarity Between Lists of Closest Genes Downstream of Peaks\nGH7 vs SH7")+ theme_bw()+ theme(axis.text.x = element_text(angle = -45, hjust = 0))  

```

TODO: GO analysis, counts


# To Do
	GO analysis
	Motif enrichment in footprints?
	Inter-pile distance?	
	
	
# Bibliography
```{r echo=FALSE}

citation("topGO")
citation("ggplot2")
citation("GGally")
citation("ggnewscale")


```


---
title: "Volkan Lab Faire-Seq"
author: "Charlie Soeder"
date: "8/16/2019"
output:
  pdf_document: 
    number_sections: yes
    toc: yes
    toc_depth: 5
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/proj/cdjones_lab/csoeder/VolkanLab_BehaviorGenetics/')
#knitr::opts_knit$set(root.dir=peaDubDee)
#install.packages("remotes")
#remotes::install_github("rstudio/gt")

library("biomaRt")
library("org.Dm.eg.db")

library("yaml")
library("readr")
library("tidyverse")
library("ggnewscale")
library("scales")

library("gt")
library("GGally")

```





```{r include=FALSE}

human_readable_croncher <- function(num_in) {
	dig <- 3
	num_out <- formatC(num_in, digits=dig, format='g') %>% as.numeric() %>% sitools::f2si()
	return(num_out)
}

bam_summary_loader <- function(filename, aligner="bwa", reference='dm6'){
	
	tmp.df <- read_delim(filename, "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
	names(tmp.df) <- c("sample","measure","value")
	
	tmp.df$sample <- as.factor(tmp.df$sample)
	tmp.df$measure <- as.factor(tmp.df$measure)
	tmp.df$aligner <- as.factor(aligner)
	tmp.df$reference <- as.factor(reference)
	
	return(tmp.df)
	
}
```




# Introduction

words words



# Materials, Methods, Data, Software

```{r include=FALSE}

trammel <- read_yaml("config.yaml")

```
generic overview words


## Reference Genomes


```{r include=FALSE}
refGenomes_summary_df <- read_delim("meta/reference_genomes.summary", 
    "\t", escape_double = FALSE, col_names = FALSE, 
    trim_ws = TRUE)

names(refGenomes_summary_df) <- c("refGenome","measure","value")

```

The dm6 reference genome was used for read alignment:
```{r echo=FALSE}

refGenomes_summary_df  %>% mutate(measure=gsub("_"," ",measure)) %>% spread(refGenome, value)   %>% gt() %>% tab_header(title="Size and Consolidation of Reference Genomes", subtitle="Drosophila Melanogaster") %>%   fmt_number(columns = vars(dm6),suffixing = TRUE, decimals=0)

```

## Reference Annotations

Reference annotations were used to locate features within the genome for comparison:

```{r echo=FALSE}

ref_ann.stats <- read_delim("meta/reference_annotations.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(ref_ann.stats) <- c("annot", "measure", "type", "value")

ref_ann.stats %>%  filter(type == 'total' | type == 'avg') %>% unite("measure", c("type", "measure"), sep = " ") %>% spread(measure, value) %>% gt()

```


In addition to the full annotations, subsets containing prespecified genes of interest will also be used.

```{r echo=FALSE, warning=FALSE, message=FALSE }

geneLists.stats <- read_delim("meta/geneLists.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(geneLists.stats) <- c("query", "annot", "measure", "type", "value")
geneLists.stats$query <- as.factor(geneLists.stats$query)
geneLists.stats$annot <- as.factor(geneLists.stats$annot)
geneLists.stats$measure <- as.factor(geneLists.stats$measure)
geneLists.stats$type <- as.factor(geneLists.stats$type)

geneList.tbl <-  geneLists.stats %>% filter(measure == "count") %>% unite(measure, type, measure, sep=" ") %>% select(c(query,measure,value)) 

geneList.tbl <- rbind(geneList.tbl, inner_join(geneLists.stats %>% filter(measure=="count" & type=="annotated"), ref_ann.stats %>% filter(measure=="count" & type=="total"), by=c("annot" = "annot"), suffix=c("", ".ann")) %>% mutate(measure = "percent of annotations", value=value/value.ann) %>% select(query, measure, value))

geneList.tbl <- rbind( geneList.tbl, geneLists.stats %>%  filter(measure == "size") %>% filter(type == "total" | type == "avg") %>% unite(measure, type, measure, sep=" ") %>% select(query, measure, value)) 

geneList.tbl <- rbind(geneList.tbl, geneLists.stats %>% filter(measure=="size" & type == "total") %>%  mutate(value = value/(refGenomes_summary_df %>% filter(measure=="number_bases") %>% select(value) %>% as.numeric() ) ) %>%  unite(measure, type, measure, sep=" ") %>% select(-c(annot)) %>% mutate(measure = "percent genome size") )


geneList.tbl <- rbind( geneList.tbl, inner_join(geneLists.stats %>% filter(measure=="size" & type == "total"), ref_ann.stats %>% filter(measure=="size" & type == "total"), by = c("annot" = "annot")) %>% mutate(value=value.x/value.y, measure = "percent annotation size") %>% select(query, measure, value) )


```

Here are those subsets and their sizes:

```{r echo=FALSE}

geneList.tbl %>% spread(query, value) %>% gt() %>% fmt_number(columns=seq(2,6), rows=str_detect(measure, "size"), decimals=1, suffixing=T) %>% fmt_number(columns=seq(2,6), rows=str_detect(measure, "count"), decimals=0, suffixing=T)  %>% fmt_percent(columns=seq(2,6), rows=str_detect(measure, "percent"), decimals=1) %>% tab_header(title="Predefined Subsets of Gene Annotation", subtitle= md("&nbsp;"))
```


TODO: mention number of distinct locii

### Ionotropic

A list of ionotropic receptors supplied by Corbin via Flybase & George et al 2019  (email 28 May 2019). This contained 335 entries, some with mutiple genes, some not unique. Once merged & uniqued : 246
Annotation symbols (CGxxxxx) gonverted to FlyBase gene games (FBgnxxxx) using flybase ID converter (http://flybase.org/convert/id) 

239 converted cleanly; 5 had duplicate conversions and were corrected by hand:
```
CG11430 is FBgn0041585, not FBgn0050323
CG43368 is FBgn0263111, not FBgn0041188
CG8885 is FBgn0262467, not FBgn0081377
CG9090 is FBgn0034497, not FBgn0082745
CG9126 is FBgn0045073, not FBgn0053180
```

Two were corrected to be consistent with the dm6_genes annotation:
```
CG9907 (para), is listed as FBgn0264255 not FBgn0285944
CG42345 (straw) is listed as FBgn0259247 (laccase2)
```

### Derived from GO terms

```
Sub Pull out by particular GO terms?
o Nervous system development - http://flybase.org/cgi-bin/cvreport.pl?rel=is_a&id=GO:0007399 
o Mating - http://flybase.org/cgi-bin/cvreport.pl?rel=is_a&id=GO:0007618
o Histone modification - http://flybase.org/cgi-bin/cvreport.pl?rel=is_a&id=GO:0016570 
o Dna-binding transcription factor - http://flybase.org/cgi-bin/cvreport.pl?id=GO%3A0003700 
o Synaptic signaling - http://flybase.org/cgi-bin/cvreport.pl?rel=is_a&id=GO:0099536 
o Synapse organization - http://flybase.org/cgi-bin/cvreport.pl?id=GO%3A0050808
```
(Bryson, email 24 July 2019)

melanogaster-specific genes with these GO terms were retrieved using th FlyBase QueryBuilder. 


Nervous System Development:
```
nrd, FBgn0002967, no annotated gene model
l(2)23Ab, FBgn0014978, same
aloof, FBgn0020609, same
Imp, FBgn0285926, is FBgn0262735
```

Mating:
```
Only three, but all good
```

synapse signalling
```
1 gene
```

Histone modification, DNA trans factor act, synapse org
```
MT
```

## Sequenced Reads
```{r include=FALSE}
data_sets.df <- plyr::ldply(trammel$data_sets, data.frame)
data_sets.df$name <- as.factor(data_sets.df$name)
data_sets.df$day<- as.factor(data_sets.df$day)
data_sets.df$experimental <- gsub("_", "-", data_sets.df$experimental)
data_sets.df$experimental<- as.factor(data_sets.df$experimental)
data_sets.df$subgroups<- as.factor(data_sets.df$subgroups)
data_sets.df$rep<- as.factor(data_sets.df$rep)

data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,path,readsfile)) %>% distinct() 

```


FAIRE-Seq reads were sequenced for four experimental treatments. Each had one "input" (in which the DNA was fragmented without crosslinking to chromatin) and three replicates in which the DNA was crosslinked and then fragmented. 

```{r echo=FALSE, results='asis'}
data_sets.df.sparse  %>% group_by(experimental,rep) %>% summarise(`sample count`=n())  %>% gt() %>%  tab_options(row_group.background.color = "#FFEFDB") 
```


To accomodate varying data quality, analyses were done on three nested subsets of the data, each including an input and at least one replicate for each experimental treatment. Groups A, B, and C correspond to 1, 2, and 3:

```
ok, do the alignment and MACS2 analysis like you did before.  Do three version: 

1) Only unmarked
2) include the orange
3) all date
```
(Corbin, 20 May 2019 email)

```{r echo = FALSE}

data_sets.df %>% select(c(experimental, rep, subgroups)) %>% mutate(dummy="1") %>% filter(subgroups!='all') %>% group_by_at(vars(-dummy)) %>%  mutate(rowid=1:n()) %>% ungroup() %>% spread(key=subgroups, value=dummy ) %>%  select(-rowid) %>% mutate(A=case_when(is.na(A) ~ "x", TRUE ~ "o" ), B=case_when(is.na(B) ~ "x", TRUE ~ "o" ) , C=case_when(is.na(C) ~ "x", TRUE ~ "o" )  ) %>% gt() %>% tab_style(style = cells_styles(text_style = "italic", text_color="red"), locations = list(cells_data(columns = vars(A), rows = A=="x"), cells_data(columns = vars(B), rows = B=="x")))

```


### Pre-Processing

These reads were preprocessed with FASTP [@Chen2018] for quality control and analytics. 


```{r echo=FALSE, include=FALSE, warning=FALSE}
fastp_summary <- read_delim("meta/sequenced_reads.dat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(fastp_summary ) <- c("name","type","measure","value")
fastp_summary$name <- as.factor(fastp_summary$name)
fastp_summary$type <- as.factor(fastp_summary$type)
fastp_summary$measure <- as.factor(fastp_summary$measure)
```


```{r echo=FALSE, include=FALSE, warning=FALSE}
filtration_stats <- inner_join(fastp_summary %>%  filter(type=="prefiltered" | type == 'postfiltered'), data_sets.df.sparse, by=c("name"="name"))
filtration_stats$type <- factor(filtration_stats$type, levels=c("prefiltered", "postfiltered"))
```


Starting FASTQ files contained a total of  $`r sum( filtration_stats %>% filter(type =='prefiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$ reads; after QC, this dropped to $`r sum( filtration_stats %>% filter(type =='postfiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$. 



```{r echo=FALSE, warning=FALSE, message=FALSE }
pre_post_counts <- filtration_stats %>% filter(measure=='total_reads') %>%  group_by(type)  %>%  summarise(minimum = min(value), average=mean(value) , maximum = max(value)) 
retention_percent <- filtration_stats %>% filter(measure=='total_reads') %>% select(c(name,type,value)) %>%  spread(type,value) %>% mutate(retention=100*postfiltered/prefiltered) %>%  summarise(type='percent retention', minimum = min(retention), average=mean(retention) , maximum = max(retention))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
rbind(pre_post_counts, retention_percent) %>% rename(" "=type) %>% gt() %>% tab_header(title="Read Retention Rate during Preprocessing", subtitle= md("&nbsp;")) %>%  fmt_number(columns = vars(minimum, average,maximum),suffixing = TRUE, decimals=0)
```



```{r echo=FALSE, warning=FALSE}
ggplot(filtration_stats %>% filter(measure == "q30_rate")) + geom_line(aes(group=name, x=type,y=100*value)) +  geom_point(aes(x=type, y = 100*value, color=experimental, shape=rep)) + labs(title = "Percent of Reads with a mean QUAL > 30", y="Percent QUAL > 30", x="") + ggbio::theme_clear() + geom_text(data= . %>% filter(type=="postfiltered") %>% filter(value<0.97), aes(type,100*value,label=name))

```


Duplicate reads were also detected; however, duplicate reads are less concerning in FAIRE-seq given the relatively smaller genome they are sampled from. 

https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/8%20Duplicate%20Sequences.html
http://seqanswers.com/forums/showthread.php?t=40440


```{r echo=FALSE, include=FALSE}
dupe_stats <- inner_join(fastp_summary %>% filter(type=='duplication' & measure =='rate') %>%  mutate(percent=value*100) %>% select(c(name,percent)), data_sets.df.sparse, by=c("name"="name"))
```

```{r echo=FALSE}
dupe_stats %>%  summarise(minimum = min(percent), average=mean(percent), median=median(percent) , maximum = max(percent)) %>% gt() %>% tab_header(title="Percentage Duplication", subtitle="FASTP estimate") %>% fmt_number(columns=vars(minimum,median,average,maximum), decimals=1, ) #kable(caption="Percentage Duplication",digits=1)
```

```{r echo=FALSE}
ggplot(dupe_stats) + geom_histogram(aes(x=percent, fill=experimental), bins=15) + labs(title="Duplication Histogram", x="Read Duplication Rate (FASTP estimate)", y="Number Samples") + ggbio::theme_clear()
```




## Mapped Reads

Reads were first mapped to the reference genome using the BWA SAMPE/SE algorithm. Currently, multimapping reads are assigned randomly and the alignments are used unfiltered. 

```{r echo=FALSE, include=FALSE}

vs_dm6.bwa <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwa.summary",aligner="bwa", reference="dm6")
#vs_dm6.bwaUniq <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwaUniq.summary",aligner="bwaUniq", reference="dm6")

all_alignments <- rbind(vs_dm6.bwa)#, vs_dm6.bwaUniq)
```




### Read & Alignment Quality


```{r echo=FALSE, warning=FALSE}
readcount_process <- all_alignments %>%  filter( measure=='total_read_count'| measure == 'total_mapped_count' ) %>% select(-c(reference, aligner))

readcount_process$measure <- factor(readcount_process$measure, levels = c('total_read_count','total_mapped_count'))
```

The mapping rate per sample can be calculated from the number of mapped reads compared to the total number of sequenced reads:

```{r echo=FALSE, warning=FALSE}
ggplot(inner_join(readcount_process%>% mutate(measure=gsub("_"," ",measure)), data_sets.df.sparse, by=c("sample"="name"))) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample,color=experimental, shape=rep))  + labs(title="Read Counts by Processing Step: Unmapped, Mapped, Filtered", x="", y="Number Reads" ) + ggbio::theme_clear() + theme(axis.text.x = element_text(angle = -45, hjust = 0), legend.position='none' ) + scale_y_log10()

```

```{r echo=FALSE}

readcount_process.spread <- readcount_process %>%  spread(measure, value) %>%  mutate(percent_mapping=100*total_mapped_count/total_read_count)#, filter_retention = filtered_mapped_count/total_mapped_count)


readcount_process.spread %>% gather(total_read_count:percent_mapping, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>% mutate(measure=gsub("_"," ",measure)) %>% gt()  %>% tab_header(title="Read Counts During Alignment & Filtration", subtitle= md("&nbsp;")) %>% fmt_number(columns=vars(minimum, average, median, maximum), rows =c(2,3), decimals=1, suffixing=TRUE)%>% fmt_number(columns=vars(minimum, average, median, maximum), rows =c(1), decimals=2)


```



## Peak Calling

MACS was used to QC pilot data, but it wasn't designed for use on FAIRE-Seq. MACS2 was extended for use with FAIRE (  https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/1756-8935-7-33 ) but has its own difficulties, such as python2/3 incompatibilities, and only running on all samples under inhomogeneous settings. Here, Fseq [@Boyle2008] is used to infer peaks from mapped reads. It does this using a kernel density estimation to find intervals with significantly (4 sigma by default) more mapped reads than expected from the average regional coverage. Additionally, a signal strength is calculated, as the highest kernel density in the interval, scaled by interval size. 

```{r echo=FALSE, warning=FALSE, message=FALSE}

basicPeakStats_vs_dm6_bwa <- read_delim("meta/basicPeakStats.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% as_tibble()
names(basicPeakStats_vs_dm6_bwa ) <- c("sample","dataType","dataSubtype","value")
basicPeakStats_vs_dm6_bwa$sample <- as.factor(basicPeakStats_vs_dm6_bwa$sample)
basicPeakStats_vs_dm6_bwa$dataType<- as.factor(basicPeakStats_vs_dm6_bwa$dataType)
basicPeakStats_vs_dm6_bwa$dataSubtype<- as.factor(basicPeakStats_vs_dm6_bwa$dataSubtype)

```

from the $`r basicPeakStats_vs_dm6_bwa %>% select(sample) %>% unique() %>% count() `$ samples,  $`r basicPeakStats_vs_dm6_bwa %>% filter(dataType=="count" & dataSubtype == "total") %>% select(value) %>% sum() %>% human_readable_croncher() `$ total peaks were called:

```{r echo=FALSE}
basicPeakStats_vs_dm6_bwa.count.sprud <- basicPeakStats_vs_dm6_bwa %>% filter(dataType == "count") %>% select(-c(dataType)) %>% spread(dataSubtype,value)

contigs <- basicPeakStats_vs_dm6_bwa.count.sprud %>% select(3:ncol(.)-1) %>% names()

basicPeakStats_vs_dm6_bwa.count.sprud %>% gt()  %>%  tab_spanner(label="by contig", columns=vars(contigs )) %>% fmt_number(columns = seq(2,10),  decimals = 1, suffixing = T)   %>% tab_header(title="Called Peak Count", subtitle= "by contig and sample")

```

We can also check the peak-calling efficiency:


```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.count.sprud.aug <- inner_join(inner_join(basicPeakStats_vs_dm6_bwa.count.sprud %>% select(c("sample","total")), data_sets.df.sparse , by = c("sample"="name")), readcount_process.spread, by=c("sample"="sample")) %>% rename("total_peak_count"=total) %>% mutate(peaks_per_thousand_sequenced_reads = 1000*total_peak_count/total_read_count, peaks_per_thousand_mapped_reads = 1000*total_peak_count/total_mapped_count)

basicPeakStats_vs_dm6_bwa.count.sprud.aug  %>% select(-c("sample", "day")) %>% select_all(~gsub("_"," ",.)) %>%  gt() %>% cols_move_to_start(columns = vars(experimental, rep)) %>% fmt_number(columns = vars(`total peak count`), suffixing = T, decimals = 1) %>% fmt_number(columns = vars(`peaks per thousand sequenced reads`, `peaks per thousand mapped reads`),  decimals = 1) %>% cols_hide(columns=vars(`total read count`, `total mapped count`, `percent mapping`)) %>% cols_label(`peaks per thousand sequenced reads` = "peaks per\nthousand sequenced reads", `peaks per thousand mapped reads`= "peaks per\nthousand mapped reads")  %>% tab_header(title="Peak Calling Efficiency", subtitle= "peaks called per read sequenced/mapped")

```

### Raw Peaks

```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.size.sprud <- basicPeakStats_vs_dm6_bwa %>% filter(dataType == "width" | dataType == "signal") %>% unite(dataSubtype, dataType, col="measure", sep=" ")  %>% spread(measure, value) %>% select(sample, `avg width`, `std width`, `avg signal`, `std signal`)

basicPeakStats_vs_dm6_bwa.size.sprud.aug <- inner_join(inner_join(basicPeakStats_vs_dm6_bwa.size.sprud, data_sets.df.sparse , by = c("sample"="name")),readcount_process.spread, by=c("sample"="sample") )

	
grand_mean_peak_width <- mean(basicPeakStats_vs_dm6_bwa.size.sprud$`avg width`)
grand_mean_signal <- mean(basicPeakStats_vs_dm6_bwa.size.sprud$`avg signal`)
```

peaks had an average width of $`r human_readable_croncher(grand_mean_peak_width) `$ base pairs. Peaks also had intensity values measuring signal enhancement over the genomic background; these averaged at $`r human_readable_croncher(grand_mean_signal) `$ Both of these values were highly variable within and between samples:

```{r gt, echo=FALSE}

basicPeakStats_vs_dm6_bwa.size.sprud.aug %>% select(experimental, rep, `avg width`, `std width`, `avg signal`, `std signal`) %>% gt() %>%  tab_spanner(label="width", columns=vars( `avg width`, `std width`)) %>%  tab_spanner(label="signal", columns=vars( `avg signal`, `std signal` )) %>% fmt_number(columns = vars(`avg width`, `std width`, `avg signal`, `std signal` ), decimals = 1, suffixing = F) %>% tab_header(title="Peak Size & Signal Strength", subtitle= md("&nbsp;")) %>% cols_label(`avg width` = "avg", `std width` = "std", `avg signal` = "avg", `std signal` = "std" )

```

```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.full.sprud.aug <- inner_join(basicPeakStats_vs_dm6_bwa.size.sprud.aug, basicPeakStats_vs_dm6_bwa.count.sprud.aug %>% select(-c(experimental,day,rep, total_read_count, total_mapped_count, percent_mapping)), by=c("sample"="sample")  )


basicPeakStats_vs_dm6_bwa.full.sprud.aug.names <- basicPeakStats_vs_dm6_bwa.full.sprud.aug %>% names()
names(basicPeakStats_vs_dm6_bwa.full.sprud.aug) <- gsub(" ","\n", gsub("_", "\n", basicPeakStats_vs_dm6_bwa.full.sprud.aug %>% names()))

ggscatmat(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg\nwidth", "std\nwidth", "avg\nsignal", "std\nsignal", "total\nread\ncount", "total\nmapped\ncount", "total\npeak\ncount" )) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title="Distributions & Correlations for Read and Peak Stats")

#ggscatmat(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg\nwidth", "avg\nsignal", "total\nread\ncount", "total\nmapped\ncount", "percent\nmapping",  "total\npeak\ncount" ), color="experimental") + theme(axis.text.x = element_text(angle = 90, hjust = 1))

names(basicPeakStats_vs_dm6_bwa.full.sprud.aug) <- basicPeakStats_vs_dm6_bwa.full.sprud.aug.names 

```



```{r echo=FALSE, message=FALSE}
raw_called_peaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$name) {
	
	tmp.df <- read_delim(paste("fSeq/",nom,".vs_dm6.bwa.calledPeaks.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% select(X1,X2,X3,X7,X10)
	names(tmp.df) <- c("chrom", "start", "stop", "signal", "center")
	tmp.df$sample <- as.factor(nom)
	raw_called_peaks.df <- rbind(raw_called_peaks.df, tmp.df)
}

raw_called_peaks.df <- raw_called_peaks.df %>% as_tibble()
raw_called_peaks.df$chrom <- as.factor(raw_called_peaks.df$chrom)

raw_called_peaks.df$peak_width <- raw_called_peaks.df$stop - raw_called_peaks.df$start
raw_called_peaks.df <- inner_join(raw_called_peaks.df, data_sets.df.sparse, by=c("sample"="name"))

```


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
of the $`r basicPeakStats_vs_dm6_bwa %>% filter(dataType=="count" & dataSubtype == "total") %>% select(value) %>% sum() %>% human_readable_croncher() `$ peaks, $`r raw_called_peaks.df %>% filter(peak_width==0) %>% nrow() %>% human_readable_croncher() `$ had a width of zero
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


```
There shouldn’t be any peaks that consist of zero bases – if you’re looking at the narrow peak file,
then the start and end positions should never be the same (which would indicate zero bases). It is a
zero-based position, so a peak with coordinates chr1:1000-1001 is a 1bp peak at chr1:1001. [...] I’ve
cc’d Alan Boyle, who wrote the software, to confirm that there should not be any zero-width peaks. I’m
at a loss here – I don’t think we’ve encountered this before.
(emails from Terry Furey, 6 Aug 2019)
```


```{r echo=FALSE, warning=FALSE}

ggplot(raw_called_peaks.df %>% gather(signal, peak_width, key="measure", value="value")) + geom_histogram(aes(x=value, fill=experimental), bins=50) +facet_grid(chrom~measure, scales="free") + scale_x_log10() + theme_bw() + labs(title="Histogram of Peak Width & Signal Strength,\nby Chromosome")

```

The consistent spike in peak width in the 47b1-7 experiment, slightly above 1kb, comes from replicate 3. This sample has an order of magnitude more peaks large than 1kb, than the other 15.

```{r echo=FALSE}
raw_called_peaks.df %>% filter(peak_width > 1000 )  %>% group_by(experimental, rep) %>% summarize(n=n()) %>%  spread(rep, n) %>% ungroup() %>% gt() %>% tab_options(footnote.glyph = c("*")) %>% tab_style(style=cells_styles(text_color='red'), locations=list(cells_data(columns=vars(3), rows=experimental == "47b1-7"))) %>%  tab_footnote(footnote = "  ", locations=list(cells_data(columns=vars(3), rows=experimental == "47b1-7"))) %>% tab_header(title="Number of Peaks Larger than 1 kb", subtitle= "by experiment and replicate")

```

47b1-7 replicate #3 is only included in the "C" analysis group (Section 2.6). 


check intrasample, inter-peak distances: look for potentially non-distinct peaks. 
```{r echo=FALSE, message=FALSE}

calledPeaks.selfDistance.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$name) {
	tmp.df <- read_delim(paste("fSeq/closest/all/",nom,".to.",nom,  ".vs_dm6.bwa.closestPeaks.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)
	#names(tmp.df) <- c("chrom", "start", "stop", "signal", "center")
	calledPeaks.selfDistance.df  <- rbind(calledPeaks.selfDistance.df , tmp.df)
}

calledPeaks.selfDistance.df <- calledPeaks.selfDistance.df  %>% as_tibble() %>% select(c(X1,X2,X3,X7,X10,X11,X12,X13,X17,X20,X21,X22))
names(calledPeaks.selfDistance.df) <- c("chrom1", "start1", "stop1", "signal1", "center1", "chrom2", "start2", "stop2", "signal2", "center2", "distance", "sample" )
calledPeaks.selfDistance.df$chrom1 <- as.factor(calledPeaks.selfDistance.df$chrom1)
calledPeaks.selfDistance.df$chrom2 <- as.factor(calledPeaks.selfDistance.df$chrom2)
calledPeaks.selfDistance.df$sample <- as.factor(calledPeaks.selfDistance.df$sample)

calledPeaks.selfDistance.df <- inner_join(calledPeaks.selfDistance.df, data_sets.df.sparse, by=c("sample"="name"))


```


The distance between adjacent peaks within a sample was measured. 


```{r echo=FALSE}

ggplot(calledPeaks.selfDistance.df %>% filter(chrom1 != "chrM")) + geom_freqpoly(aes(x=abs(distance), color=rep), bins=50) + facet_grid(experimental ~ chrom1) + scale_x_log10() +theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Distance Between Adjacent Peaks,\nby sample and replicate", x= "distance (bp)") + theme_bw()

```

Some peaks were very close to other peaks; as many as 20% of peaks were within 10bp of another one, and as many as 65% were within 100 bp:

```{r echo=FALSE}
closePeaks <- calledPeaks.selfDistance.df %>% filter(abs(distance)<10) %>% group_by(sample) %>% summarise(lessThan10 = n() )
closePeaks <- cbind( closePeaks, calledPeaks.selfDistance.df %>% filter(abs(distance)<100) %>% group_by(sample) %>% summarise(lessThan100 = n() ) %>% select(lessThan100))

#closePeaks <- 
inner_join(closePeaks, basicPeakStats_vs_dm6_bwa.full.sprud.aug, by=c("sample"="sample")) %>% mutate(lessThan10 = lessThan10/total_peak_count, lessThan100 = lessThan100/total_peak_count, potato = "")  %>% select(experimental, rep, lessThan10, lessThan100, potato) %>% group_by(experimental) %>% gt(rowname_col = "potato") %>% fmt_percent(columns=vars(lessThan10, lessThan100), decimals = 1) %>% tab_stubhead_label(label="experimental treatment") %>% cols_label(lessThan10 = "< 10 bp", lessThan100 = "< 100 bp") %>% tab_header(title="Percentage of Peaks Very Close to Other Peaks", subtitle= "within a sample")

#ggplot(calledPeaks.selfDistance.df %>% mutate(one=stop1-start1, two = stop2-start2, distance=abs(distance)) %>% select(one, two, distance, experimental, rep) %>% gather(one, two, key="peak", value="width") ) + geom_point(aes(x=distance, y=width), alpha=0.1) + facet_grid(.~peak)

```

### Collapsed Peaks ( within input/output )

Although the inputs consisted of a single replicate, each experimental output had three replicates. These were collapsed into a single set of peaks each for every input and output. The collapsed peak region was defined as the union of all peaks being considered. Calculating a combined signal value for multiple peaks is an open problem; several approaches are tested here:
```
	* Average: a flat average of the component peaks' signal values
	* Rescale: in which the component peaks' maximum kernel densities are averaged,
	and then scaled by final peak width
	* Weighted: like Rescale, but the average max kernel density is weighted by
	the component peak widths
	* Pessimistic: like Weighted, but the result is further scaled by the fraction
	of replicates supporting a peak in this region.  
	* Fine: (in development)
```

All strategies but Average will give NA for singleton zero-width peaks. 

```{r echo=FALSE, message=FALSE}

collapsedPeaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
	
#	for (treat in c("input","output")){
	for (treat in c("output")){		
		for (grup in c("A", "B", "C")) {
			tmp.df <- read_delim(paste("fSeq/collapse/",gsub("-", "_", nom),".vs_dm6.bwa.","group_",grup,".",treat,".signalsCollapsed.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
			names(tmp.df) <- c("chrom", "start", "stop", "count", "avg", "rescale", "weight", "pess")
			tmp.df$chrom <- as.factor(tmp.df$chrom)
			tmp.df$treat <- as.factor(treat)
			tmp.df$experimental <- as.factor(nom)
			tmp.df$group <- as.factor(grup)
			collapsedPeaks.df <- rbind(collapsedPeaks.df, tmp.df)
		}
	}
}

collapsedPeaks.df <- collapsedPeaks.df %>% as_tibble()

collapsedPeaks.df$peak_width <- collapsedPeaks.df$stop - collapsedPeaks.df$start


```

Since the inputs consist of one replicate each, their collapsed peaks are identical to their raw peaks (except for those with a width of zero, whose collapsed signal strengths are NA except for the flat average). In the case of the outputs, with 1-3 replicates depending on experimental treatment and 


```{r echo=FALSE, message=FALSE}

collapsedPeaks.gath <- collapsedPeaks.df %>%  gather(key = "measure", value = "value", c(avg, rescale, weight, pess))

measureList <- levels(collapsedPeaks.gath$measure)
collapsedPeaks.gath$measure<- as.factor(collapsedPeaks.gath$measure)
measureList <- levels(collapsedPeaks.gath$measure)
collapsedPeaks.gath$measure <- factor(collapsedPeaks.gath$measure, levels = c("raw", measureList ))

raw_called_peaks.signlXtract <- raw_called_peaks.df %>%  mutate(measure = as.factor("raw"))
raw_called_peaks.signlXtract$measure <- factor(raw_called_peaks.signlXtract$measure, levels = c("raw", measureList ))



hiPass.raw <- raw_called_peaks.signlXtract %>% filter(rep != "input") %>% mutate(high = signal > 20) %>% group_by(high) %>% summarize( count = n()) %>% mutate( frac = count/sum(count))
hiPass.clps <- collapsedPeaks.gath  %>% mutate(high = value > 20) %>% group_by(high) %>% summarize( count = n()) %>% mutate( frac = count/sum(count))



```

When the small number (`r hiPass.raw$frac[2]*100` percent of raw peaks,  `r  hiPass.clps$frac[2]*100` percent of collapsed peaks ) of high-signal outliers  (raw or collapsed signal > 20) were excluded, the distributions of the raw/collapsed signals were as follows

```{r echo=FALSE, warning=FALSE}

ggplot(collapsedPeaks.gath %>%  filter(value<20)) + geom_violin(data = inner_join(raw_called_peaks.signlXtract %>% filter(rep != "input") %>% select(sample, signal, rep, measure),data_sets.df %>% filter(subgroups != "all" & rep != "input") %>% select(name, subgroups, experimental) %>% rename(group=subgroups),by=c("sample"="name")) %>%  filter(signal<20), aes(x=measure, y=signal, fill=rep)) + geom_violin(aes(x=measure, y=value)) + facet_grid(group~experimental) + scale_y_log10() + scale_x_discrete(limits=c("raw", "avg", "rescale", "weight", "pess")) + labs(x = "signal type", y= "signal intensity", title="Comparison of Signal-Collapsing Strategies\n( Outliers with Intensity > 20 Removed)") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) 

```

The impact of lower-quality replicates and their exclusion across groups is apparent in the collapsed signal strength distributions. The strategies are generally comparable in distribution, except for Pessimist which is skewed lower and apears to have a smoothing effect. 

```{r echo=FALSE}
full_samp <- collapsedPeaks.df %>% mutate(macks = pmax(avg, rescale, weight, pess)) %>%  filter(macks<20) %>% nrow()

ggscatmat(collapsedPeaks.df %>% mutate(macks = pmax(avg, rescale, weight, pess)) %>%  filter(macks<20) %>% sample_n(floor(full_samp/100)), columns = c( "avg", "rescale", "weight", "pess" )) + theme(axis.text.x = element_text(angle = -45, hjust = 1)) + labs(title="Distributions and Correllations of Various Signal Collapsing Strategies\n(Outliers with Intensity > 20 Removed, Downsampled To 1%)")

#ggscatmat(collapsedPeaks.df %>% mutate(macks = pmax(avg, rescale, weight, pess)) %>%  filter(macks>20), columns = c( "avg", "rescale", "weight", "pess" )) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title="Distributions and Correllations of Various Signal Collapsing Strategies\n(Outliers with Intensity < 20 ")
```

One thing that stands out is that, because of the length-weighting step, the Pessimistic values are sometimes much higher than the flat averages (though on the whole they are smaller)

The results are similar for the high-signal outliers, except the correllations are even stronger. 


```{r echo=FALSE, message=FALSE, warning=FALSE}

collapsedPeakStats.autoDist.df <- read_delim("meta/collapsedPeakStats.vs_dm6.bwa.autoDist.hist", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(collapsedPeakStats.autoDist.df) <- c("experimental", "group", "put", "chrom", "dist", "count")
collapsedPeakStats.autoDist.df$process <- as.factor("raw")

#ggplot(collapsedPeakStats.autoDist.df %>% group_by(experimental, group, put, dist) %>%  summarise(count = sum(count)) %>% mutate(process=as.factor("collapsed")))  + geom_line(aes(x=dist, y=count, color=process))  + geom_line(aes(x=dist, y=count, color=process))  + facet_grid(experimental ~ put)

```

```{r echo=FALSE}
ggplot( calledPeaks.selfDistance.df %>% select(c(experimental, rep, distance)) %>% mutate(dist = abs(distance), put = as.factor(case_when(rep!="input"~"output", rep=="input"~"input")) ) %>% group_by(experimental, rep, dist, put) %>% summarise(count = n()) %>%  ungroup() %>% mutate(process=as.factor("raw"), experimental = gsub("-", "_", experimental))) + geom_line(aes(x=dist, y=count, color=process, group=rep)) + geom_line(data=collapsedPeakStats.autoDist.df %>% group_by(experimental, group, put, dist) %>%  summarise(count = sum(count)) %>% mutate(process=as.factor("collapsed")), aes(x=dist, y=count, color=process, linetype = group))  + facet_grid(experimental ~ put) + scale_x_log10() +theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Distance Between Adjacent Peaks (Raw & Collapsed),\nby sample and replicate", x= "distance (bp)") 



```



### Merged Peaks (proximity within input/output)

Once the peaks have been collapsed within a treatment, the issue of nearby peaks not being distinct remains. It is trivial to merge nearby peaks into a single feature, but the issue of how to combine signal strengths remains. 

The same basic strategies were used to merge signals of disconnected peaks. One important difference is that, whereas collapsing peaks across replicates assigns a signal to regions with some peak coverage, merging nearby peaks assigns a signal to basepairs which previously had none. This will tend to make the rescaling step a more severe reduction since the nonzero signal is being averaged with the zero signal regions. Also, since the point of collapsing peaks was to reduce the replicate count to one in each case, Pessimistic will necessarily equal Weighted and is excluded. 



```{r echo=FALSE, message=FALSE}

mergedPeaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
	
	for (treat in c("input","output")){
		for (grup in c("A", "B", "C")) {
			tmp.df <- read_delim(paste("fSeq/merge/",gsub("-", "_", nom),".vs_dm6.bwa.","group_",grup,".",treat,".signalsMerged.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
			names(tmp.df) <- c("chrom", "start", "stop", "count", "avg", "rescale", "weight")
			tmp.df$chrom <- as.factor(tmp.df$chrom)
			tmp.df$treat <- as.factor(treat)
			tmp.df$experimental <- as.factor(nom)
			tmp.df$group <- as.factor(grup)
			mergedPeaks.df <- rbind(mergedPeaks.df, tmp.df)
		}
	}
}

mergedPeaks.df <- mergedPeaks.df %>% as_tibble()

mergedPeaks.df$peak_width <- mergedPeaks.df$stop - mergedPeaks.df$start

mergedPeaks.gath <- mergedPeaks.df %>%  gather(key = "measure", value = "value", c(avg, rescale, weight))

```




```{r echo=FALSE}

ggplot(mergedPeaks.gath %>%  filter(value<20) ) + geom_violin(data = collapsedPeaks.gath %>% filter(value<20) %>%  filter(measure == "pess"), aes(x=measure, y=value),fill="red") + geom_violin(aes(x=measure, y=value)) + facet_grid(group~experimental) + scale_y_log10() + scale_x_discrete(limits=c("pess", "avg", "rescale", "weight")) + labs(x = "signal type", y= "signal intensity", title="Comparison of Signal-Merging Strategies\n( Outliers with Intensity > 20 Removed; Signal to be Merged in Red)")+ theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) 


```




```{r echo=FALSE, message=FALSE}
collapsedPeakStats <- read_delim("meta/collapsedPeakStats.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(collapsedPeakStats) <- c("experimental","group","treatment","measure","type","value")
collapsedPeakStats$stage <- as.factor("collapsed")

mergedPeakStats <- read_delim("meta/mergedPeakStats.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(mergedPeakStats) <- c("experimental","group","treatment","measure","type","value")
mergedPeakStats$stage <- as.factor("merged")

rbind(collapsedPeakStats, mergedPeakStats) %>% filter(treatment == "input" ) %>% filter( type =="avg" | type == "total") %>% unite("measure", type, measure, sep = " ")  %>% select(-c(group, treatment)) %>% distinct() %>% spread(stage, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt()  %>% fmt_number(columns = vars(collapsed, merged ), decimals = 1, suffixing = F) %>%  cols_label(measure = " ") %>% tab_header(title="Input Peak Count, Size & Signal Strength", subtitle= md("Collapsed across Replicates and Merged by Proximity"))
```

```{r echo=FALSE, message=FALSE}


rbind(collapsedPeakStats, mergedPeakStats) %>% filter(treatment == "output" ) %>% filter( measure =="count" & type == "total")  %>% select(-c(treatment, measure, type)) %>% spread(stage, value)%>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt()  %>% fmt_number(columns = vars(collapsed, merged ), decimals = 1, suffixing = T) %>%  cols_label(group = " ") %>% tab_header(title="Output Peak Count", subtitle= md("Collapsed across Replicates and Merged by Proximity"))

```

```{r echo=FALSE, message=FALSE}

rbind(collapsedPeakStats, mergedPeakStats) %>% filter(treatment == "output" ) %>% filter( measure =="width" & type == "avg")  %>% select(-c(treatment, measure, type)) %>% spread(stage, value) %>% mutate(experimental=as.factor(gsub("_","-",experimental)))%>% group_by(experimental) %>% gt()  %>% fmt_number(columns = vars(collapsed, merged ), decimals = 1, suffixing = T) %>%  cols_label(group = " ") %>% tab_header(title="Output Peak Size", subtitle= md("Collapsed across Replicates and Merged by Proximity"))

```

```{r echo=FALSE, message=FALSE}

rbind(collapsedPeakStats, mergedPeakStats) %>% filter(treatment == "output" ) %>% filter( measure =="signal" & type == "avg")  %>% select(-c(treatment, measure, type)) %>% spread(stage, value)%>% mutate(experimental=as.factor(gsub("_","-",experimental))) %>% group_by(experimental) %>% gt()  %>% fmt_number(columns = vars(collapsed, merged ), decimals = 1, suffixing = T) %>%  cols_label(group = " ") %>% tab_header(title="Output Peak Signal", subtitle= md("Collapsed across Replicates and Merged by Proximity"))


```

	
```{r echo=FALSE, message=FALSE}

mergedPeakStats.autoDist.df <- read_delim("meta/mergedPeakStats.vs_dm6.bwa.autoDist.hist", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(mergedPeakStats.autoDist.df) <- c("experimental", "group", "put", "chrom", "dist", "count")
mergedPeakStats.autoDist.df$process <- as.factor("merged")


ggplot( calledPeaks.selfDistance.df %>% select(c(experimental, rep, distance)) %>% mutate(dist = abs(distance), put = as.factor(case_when(rep!="input"~"output", rep=="input"~"input")) ) %>% group_by(experimental, rep, dist, put) %>% summarise(count = n()) %>%  ungroup() %>% mutate(process=as.factor("raw"), experimental = gsub("-", "_", experimental)))  + geom_line(aes(x=dist, y=count, color=process, group=rep))  + geom_line(data=collapsedPeakStats.autoDist.df %>% group_by(experimental, group, put, dist) %>%  summarise(count = sum(count)) %>% mutate(process=as.factor("collapsed")), aes(x=dist, y=count, color=process, linetype = group)) + geom_line(data=mergedPeakStats.autoDist.df %>% filter(chrom != "chrM") %>% group_by(experimental, group, put, dist) %>%  summarise(count = sum(count)) %>% mutate(process=as.factor("merged")), aes(x=dist, y=count, color=process, linetype = group)) + geom_vline(xintercept = 100, color = 'red', linetype = "dashed")+ facet_grid(experimental ~ put) + scale_x_log10() +theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Distance Between Adjacent Peaks (Raw, Collapsed, and Merged),\nby sample and replicate", x= "distance (bp)") 



```	


Is 100 bp a large enough merging threshold? would we expect the merged distance distributution to be more normal?


```{r echo=FALSE, message=FALSE}

peakSquishProcessStats.tbl <- rbind(rbind(collapsedPeakStats, mergedPeakStats )   %>%  filter(type=="total"|type=="avg"), inner_join(basicPeakStats_vs_dm6_bwa %>%  filter(dataSubtype=="total"|dataSubtype=="avg"), data_sets.df.sparse , by = c("sample"="name")) %>%  mutate(stage = as.factor("raw"), group = rep, measure=dataType, type = dataSubtype, treatment = as.factor(case_when(rep!="input"~"output", rep=="input"~"input")) ) %>% select(c(experimental, group, treatment, measure, type, value, stage)) ) %>% mutate(experimental = gsub("-", "_", experimental)) %>%  filter(measure=="count" | measure =="width" | measure=="signal")

#rbind(collapsedPeakStats, mergedPeakStats) %>% mutate(rep = as.factor(NA))

#inner_join(basicPeakStats_vs_dm6_bwa %>%  filter(dataSubtype=="total"|dataSubtype=="avg"), data_sets.df.sparse , by = c("sample"="name")) %>%  mutate(stage = as.factor("raw"), group = NA, measure=dataType, type = dataSubtype, treatment = as.factor(case_when(rep!="input"~"output", rep=="input"~"input")) ) %>% select(c(experimental, group, treatment, measure, type, value, stage, rep))


ggplot(peakSquishProcessStats.tbl) + geom_point(aes(x=stage, y = value, color=experimental)) + facet_grid(measure~treatment, scales = "free_y") + scale_x_discrete(limits=c("raw", "collapsed", "merged"))+theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + geom_line(data = peakSquishProcessStats.tbl %>% group_by(experimental, treatment, measure, stage) %>% summarise(avg = mean(value)) , aes(x=stage, y=avg, color = experimental, group = experimental)) + labs(title = "Changes in Peak Properties during Merging Process,\nby sample and replicate", x= "stage") 



```


## Peak Contrasts (input vs output)

Once peak data have been consolidated to a single track per input & ouput, they are contrasted across input & output. This is done by partitioning the peaks into three piles based on the same proximity threshold used to merge them:

```
shared: peaks in input which are within 100bp of a peak in output, and vice versa
input exclusive: peaks in input which are more than 100bp from the nearest peak in output
output exclusive: peaks in output which are more than 100bp from the nearest peak in intput
```

??? further consolidate the shared peaks ?????

## Compare 


# Results

## Input vs Output Contrast (by group & treatment)

```{r echo=FALSE, message=FALSE}

contrastedPeakStats_shared.df <- read_delim("meta/contrastedPeakStats.shared.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% as_tibble()
names(contrastedPeakStats_shared.df) <-c("experimental", "group", "measure", "type", "value")

contrastedPeakStats_shared.df %>% mutate( experimental =  gsub("_", "-", experimental)) %>% filter(type =="avg" | measure == "count" | type == "total") %>% unite(measure, type, "measure") %>% spread(key=measure, value=value) %>% mutate(input_intersect_frac = input_intersect_count/input_count, output_intersect_frac = output_intersect_count/output_count) %>% select(-c(input_intersect_count,output_intersect_count)) %>% group_by(experimental) %>% gt() %>% cols_label(avg_input_width = "input", avg_output_width = "output", avg_input_signal = "input", avg_output_signal = "output",input_count = "input", output_count = "output", locii_count = "count", avg_locii_width="avg width", total_locii_width = "total width",avg_input_dist = "input", avg_output_dist = "output", avg_input_non0dist = "input", avg_output_non0dist = "output", input_intersect_frac = "input", output_intersect_frac ="output", group = " ") %>% tab_spanner(label = "avg peak width (bp)", columns =c("avg_input_width", "avg_output_width"))%>% tab_spanner(label = "avg signal", columns =c("avg_input_signal", "avg_output_signal"))  %>% tab_spanner(label = "number peaks shared", columns =c("input_count", "output_count"))   %>% tab_spanner(label = "distinct shared locii", columns =c("locii_count","avg_locii_width", "total_locii_width"))  %>% tab_spanner(label = "average interpeak distance", columns =c("avg_input_dist","avg_output_dist"))   %>% tab_spanner(label = "average interpeak distance\n(overlaps excluded)", columns =c("avg_input_non0dist","avg_output_non0dist"))  %>% tab_spanner(label = "percent overlapping", columns =c("input_intersect_frac", "output_intersect_frac")) %>% fmt_number(columns = c("avg_input_width", "avg_output_width", "avg_input_dist", "avg_output_dist", "avg_input_non0dist", "avg_output_non0dist", "avg_locii_width", "total_locii_width" ), decimals = 1, suffixing = T) %>% fmt_number(columns = c("avg_input_signal", "avg_output_signal"), decimals = 2) %>% fmt_number(columns = c("input_count", "output_count", "locii_count"), decimals = 1, suffixing = T) %>% fmt_percent(columns = vars(output_intersect_frac, input_intersect_frac), decimals = 1, drop_trailing_zeros = TRUE) %>% tab_header(title="Properties of Locii Shared Between Input and Output", subtitle= "and their contributing peaks")%>% cols_hide( columns = vars(total_input_width,total_output_width))











```

```{r echo=FALSE, message=FALSE}

contrastedPeakStats_xclsv.df <- read_delim("meta/contrastedPeakStats.exclusive.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% as_tibble()
names(contrastedPeakStats_xclsv.df) <-c("experimental", "group", "exclusive", "measure", "type", "value")

contrastedPeakStats_xclsv.df %>% mutate( experimental =  gsub("_", "-", experimental)) %>% filter(type == "avg" | type == "count" | type == "total") %>% unite("measure", exclusive, measure, type ) %>% spread(key = measure, value = value) %>% group_by(experimental)  %>% gt() %>% tab_spanner(label = "avg signal", columns =c("input_signal_avg", "output_signal_avg")) %>% tab_spanner(label = "number of peaks", columns =c("input_total_count", "output_total_count")) %>% tab_spanner(label = "avg peak width (bp)", columns =c("input_width_avg", "output_width_avg"))  %>% tab_spanner(label = "avg distance to other", columns =c("input_nearest_avg", "output_nearest_avg")) %>% tab_spanner(label = "total peak width", columns =c("output_width_total", "input_width_total")) %>% cols_label(input_signal_avg = "input", output_signal_avg = "output", input_total_count="input", output_total_count = "output", input_width_avg = "input", output_width_avg = "output",input_nearest_avg = "input", output_nearest_avg = "output", input_width_total = "input", output_width_total = "output", group = " ") %>% fmt_number(columns = c("input_signal_avg", "output_signal_avg"), decimals = 2)   %>% fmt_number(columns = c("input_width_avg", "output_width_avg", "input_total_count", "output_total_count", "input_nearest_avg", "output_nearest_avg", "output_width_total", "input_width_total"), decimals = 1, suffixing = T) %>% tab_header(title="Properties of Peaks Disjoint Between Input and Output", subtitle= md("&nbsp;") ) 

```


```{r echo=FALSE, message=FALSE}

#contrastedPeakStats.counts <- rbind(contrastedPeakStats_shared.df %>% filter(measure == "count") %>% filter(type == "input" | type == "output")  %>% mutate(pile = as.factor("shared"), put = as.factor(type)) %>% select(c(experimental, group, put, pile, value)), contrastedPeakStats_xclsv.df %>%  filter(type == "count" & measure == "total" ) %>% mutate(put = as.factor(exclusive), pile = as.factor("exclusive"))  %>% select(c(experimental, group, put, pile, value)) )


#contrastedPeakStats_shared.df %>% filter(type == "input_intersect" | type == "output_intersect" ) %>%  separate(type, into = c("put","pile")) %>% mutate(pile = as.factor("shared"), put = as.factor(put)) %>% select(c(experimental, group, put, pile, value)) , 
contrastedPeakStats.counts <- rbind(contrastedPeakStats_shared.df %>% filter(type == "input" | type == "output" ) %>% mutate(pile = as.factor("shared"), put = as.factor(type)) %>% select(c(experimental, group, put, pile, value)), contrastedPeakStats_xclsv.df %>%  filter(type == "count" ) %>% mutate(put = as.factor(exclusive), pile = as.factor("exclusive"))  %>% select(c(experimental, group, put, pile, value)))



####		whats up with the off by ones here???
#inner_join(contrastedPeakStats.counts %>% group_by(experimental, group, put) %>% summarise(some=sum(value)), mergedPeakStats %>% filter(measure=="count" & type =="total"), by=c("put"="treatment", "experimental"="experimental", "group"="group")) %>% mutate(diff = some - value)


ggplot(contrastedPeakStats.counts) + geom_col(aes(x=put, y=value, fill = pile)) + geom_col(data = mergedPeakStats %>% filter(measure=="count" & type =="total") %>% mutate(put = as.factor(treatment)) %>% select(c(experimental, group, put, value)), aes(x=put, y=value),color = "black", alpha =0) + facet_grid(experimental~group) + theme_bw() + scale_fill_discrete(name="contrast") + labs(title="Shared and Exclusive Peaks Amongst Groups and Experimental Treatments", x = "Partition", y="count") 

```




## Contrasted Peaks and Annotated Genes

Once peaks have been called, collapsed & merged, and contrasted, they are compared to the dm6 gene annotation track. 

Here are the shared peaks

```{r echo=FALSE, message=FALSE}

sharedPeaks_dm6geneIntersect <- read_delim("meta/contrastPeakIntersects.shared.dm6_genes.stat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(sharedPeaks_dm6geneIntersect ) <- c("experimental", "group", "measure", "type", "value")




sharedPeaks_dm6geneIntersect %>% mutate( experimental =  gsub("_", "-", experimental))%>% filter(measure == "count" | type == "avg")%>% unite("measure", measure, type) %>% spread(key = measure, value = value) %>% mutate(intersect_frac_annot = count_intersect/(count_intersect+count_nointersect), intersect_frac_loc = count_intersecting_locii/count_total_locii) %>% group_by(experimental) %>% gt() %>% cols_label(intersect_frac_annot = "genes", intersect_frac_loc  = "locii", locus_cov_avg = "locus", annot_cov_avg = "gene", count_intersect = "genes overlapped", group = " ") %>% tab_spanner(label = "percent intersecting", columns =c("intersect_frac_annot", "intersect_frac_loc") ) %>% tab_spanner(label = "percent overlap", columns =c("locus_cov_avg", "annot_cov_avg"))  %>% fmt_percent(columns = c("intersect_frac_annot", "intersect_frac_loc","locus_cov_avg", "annot_cov_avg"), decimals = 1) %>% tab_header(title="Locii Shared Between Input and Output", subtitle= md("and their intersections with dm6_genes") )  %>% cols_hide(c("count_intersecting_locii", "count_nointersect", "count_total_locii"))

```



```{r echo=FALSE, message=FALSE}

exclusivePeaks_dm6geneIntersect <- read_delim("meta/contrastPeakIntersects.exclusive.dm6_genes.stat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(exclusivePeaks_dm6geneIntersect ) <- c("experimental", "group", "exclusive", "measure", "type", "value")




exclusivePeaks_dm6geneIntersect %>% mutate( experimental =  gsub("_", "-", experimental)) %>% filter(measure == "count" | type == "avg")%>% unite("measure", exclusive, measure, type) %>% spread(key = measure, value = value)  %>% mutate(input_intersect_frac_annot = input_count_intersect/(input_count_intersect+input_count_nointersect), input_intersect_frac_peak = input_count_intersecting_peaks/input_count_total_peaks, output_intersect_frac_annot = output_count_intersect/(output_count_intersect+output_count_nointersect), output_intersect_frac_peak = output_count_intersecting_peaks/output_count_total_peaks) %>% group_by(experimental) %>% gt() %>% tab_spanner(label = "percent genes intersecting", columns =c("input_intersect_frac_annot", "output_intersect_frac_annot") ) %>% tab_spanner(label = "percent peaks intersecting", columns =c("input_intersect_frac_peak", "output_intersect_frac_peak") ) %>% tab_spanner(label = "average signal", columns =c("input_signal_avg", "output_signal_avg") ) %>% tab_spanner(label = "number genes intersected", columns =c("input_count_intersect", "output_count_intersect") ) %>% tab_spanner(label = "average percent gene overlapped (per peak)", columns =c("input_annot_cov_avg", "output_annot_cov_avg") )%>% tab_spanner(label = "average percent peak overlapped", columns =c("input_peak_cov_avg", "output_peak_cov_avg") ) %>% cols_label(input_intersect_frac_annot="input", output_intersect_frac_annot="output", input_intersect_frac_peak = "input", output_intersect_frac_peak = "output", input_signal_avg = "input", output_signal_avg = "output", input_count_intersect = "input", output_count_intersect = "output", input_annot_cov_avg="input", output_annot_cov_avg = "output" , input_peak_cov_avg = "input", output_peak_cov_avg = "output", group = " ") %>% fmt_percent(columns = c("input_intersect_frac_annot", "output_intersect_frac_annot","input_intersect_frac_peak", "output_intersect_frac_peak", "input_annot_cov_avg", "output_annot_cov_avg", "input_peak_cov_avg", "output_peak_cov_avg"), decimals = 1) %>% fmt_number(columns = c("input_signal_avg", "output_signal_avg"), decimals = 2) %>% fmt_number(columns = c("input_count_intersect", "output_count_intersect"), decimals = 1, suffixing = T) %>% cols_hide(columns = vars(input_count_intersecting_peaks,input_count_nointersect,input_count_total_peaks,output_count_intersecting_peaks, output_count_nointersect,output_count_total_peaks))  %>% tab_header(title="Peaks Exclusive Between Input and Output", subtitle= md("and their intersections with dm6_genes") ) 
```


## Peaks and Annotated Repetitive Elements

Repetitive DNA, such as low-complexity regions or retroelements, can also be important. Peaks were compared to the dm6 RepeatMasker annotation in the same manner as the gene annotation.



# Bibliography
```{r echo=FALSE}

citation("topGO")
citation("ggplot2")
citation("GGally")
citation("ggnewscale")

```


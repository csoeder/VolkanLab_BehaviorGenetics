---
title: "Volkan Lab Faire-Seq"
author: "Charlie Soeder"
date: "8/1/2019"
output:
  pdf_document: 
    number_sections: yes
    toc: yes
    toc_depth: 5
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/proj/cdjones_lab/csoeder/VolkanLab_BehaviorGenetics/')
#knitr::opts_knit$set(root.dir=peaDubDee)
#install.packages("remotes")
#remotes::install_github("rstudio/gt")

library("biomaRt")
library("org.Dm.eg.db")

library("yaml")
library("readr")
library("tidyverse")
library("ggnewscale")
library("scales")

library("gt")
library("GGally")

```





```{r include=FALSE}

human_readable_croncher <- function(num_in) {
	dig <- 3
	num_out <- formatC(num_in, digits=dig, format='g') %>% as.numeric() %>% sitools::f2si()
	return(num_out)
}

bam_summary_loader <- function(filename, aligner="bwa", reference='dm6'){
	
	tmp.df <- read_delim(filename, "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
	names(tmp.df) <- c("sample","measure","value")
	
	tmp.df$sample <- as.factor(tmp.df$sample)
	tmp.df$measure <- as.factor(tmp.df$measure)
	tmp.df$aligner <- as.factor(aligner)
	tmp.df$reference <- as.factor(reference)
	
	return(tmp.df)
	
}
```




# Introduction

words words



# Materials, Methods, Data, Software

```{r include=FALSE}

trammel <- read_yaml("config.yaml")

```
generic overview words


## Reference Genomes


```{r include=FALSE}
refGenomes_summary_df <- read_delim("meta/reference_genomes.summary", 
    "\t", escape_double = FALSE, col_names = FALSE, 
    trim_ws = TRUE)

names(refGenomes_summary_df) <- c("refGenome","measure","value")

```

The dm6 reference genome was used for read alignment:
```{r echo=FALSE}

refGenomes_summary_df  %>% mutate(measure=gsub("_"," ",measure)) %>% spread(refGenome, value)   %>% gt() %>% tab_header(title="Size and Consolidation of Reference Genomes", subtitle="Drosophila Melanogaster") %>%   fmt_number(columns = vars(dm6),suffixing = TRUE, decimals=0)

```

## Reference Annotations

Reference annotations were used to locate features within the genome for comparison:

```{r include=FALSE}

ref_ann.stats <- read_delim("meta/reference_annotations.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(ref_ann.stats) <- c("annot", "measure", "type", "value")

ref_ann.stats %>%  filter(type == 'total' | type == 'avg') %>% unite("measure", c("type", "measure"), sep = " ") %>% spread(measure, value) %>% gt()

```





In addition to the full annotations, subsets containing prespecified genes of interest will also be used.

```{r echo=FALSE, warning=FALSE, message=FALSE }

geneLists.stats <- read_delim("meta/geneLists.stats", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)

names(geneLists.stats) <- c("query", "annot", "measure", "type", "value")
geneLists.stats$query <- as.factor(geneLists.stats$query)
geneLists.stats$annot <- as.factor(geneLists.stats$annot)
geneLists.stats$measure <- as.factor(geneLists.stats$measure)
geneLists.stats$type <- as.factor(geneLists.stats$type)

geneList.tbl <-  geneLists.stats %>% filter(measure == "count") %>% unite(measure, type, measure, sep=" ") %>% select(c(query,measure,value)) 

geneList.tbl <- rbind(geneList.tbl, inner_join(geneLists.stats %>% filter(measure=="count" & type=="annotated"), ref_ann.stats %>% filter(measure=="count" & type=="total"), by=c("annot" = "annot"), suffix=c("", ".ann")) %>% mutate(measure = "percent of annotations", value=value/value.ann) %>% select(query, measure, value))

geneList.tbl <- rbind( geneList.tbl, geneLists.stats %>%  filter(measure == "size") %>% filter(type == "total" | type == "avg") %>% unite(measure, type, measure, sep=" ") %>% select(query, measure, value)) 

geneList.tbl <- rbind(geneList.tbl, geneLists.stats %>% filter(measure=="size" & type == "total") %>%  mutate(value = value/(refGenomes_summary_df %>% filter(measure=="number_bases") %>% select(value) %>% as.numeric() ) ) %>%  unite(measure, type, measure, sep=" ") %>% select(-c(annot)) %>% mutate(measure = "percent genome size") )


geneList.tbl <- rbind( geneList.tbl, inner_join(geneLists.stats %>% filter(measure=="size" & type == "total"), ref_ann.stats %>% filter(measure=="size" & type == "total"), by = c("annot" = "annot")) %>% mutate(value=value.x/value.y, measure = "percent annotation size") %>% select(query, measure, value) )


```

Here are those subsets and their sizes:

```{r echo=FALSE}

geneList.tbl %>% spread(query, value) %>% gt() %>% fmt_number(columns=seq(2,6), rows=str_detect(measure, "size"), decimals=1, suffixing=T) %>% fmt_number(columns=seq(2,6), rows=str_detect(measure, "count"), decimals=0, suffixing=T)  %>% fmt_percent(columns=seq(2,6), rows=str_detect(measure, "percent"), decimals=1) %>% tab_header(title="Predefined Subsets of Gene Annotation", subtitle= md("&nbsp;"))
```


TODO: mention number of distinct locii

### Ionotropic

A list of ionotropic receptors supplied by Corbin via Flybase & George et al 2019  (email 28 May 2019). This contained 335 entries, some with mutiple genes, some not unique. Once merged & uniqued : 246
Annotation symbols (CGxxxxx) gonverted to FlyBase gene games (FBgnxxxx) using flybase ID converter (http://flybase.org/convert/id) 

239 converted cleanly; 5 had duplicate conversions and were corrected by hand:
```
CG11430 is FBgn0041585, not FBgn0050323
CG43368 is FBgn0263111, not FBgn0041188
CG8885 is FBgn0262467, not FBgn0081377
CG9090 is FBgn0034497, not FBgn0082745
CG9126 is FBgn0045073, not FBgn0053180
```

Two were corrected to be consistent with the dm6_genes annotation:
```
CG9907 (para), is listed as FBgn0264255 not FBgn0285944
CG42345 (straw) is listed as FBgn0259247 (laccase2)
```

### Derived from GO terms

Nervous System Development:
```
nrd, FBgn0002967, no annotated gene model
l(2)23Ab, FBgn0014978, same
aloof, FBgn0020609, same
Imp, FBgn0285926, is FBgn0262735
```

Mating:
```
Only three, but all good
```

synapse signalling
```
1 gene
```

Histone modification, DNA trans factor act, synapse org
```
MT
```

## Sequenced Reads
```{r include=FALSE}
data_sets.df <- plyr::ldply(trammel$data_sets, data.frame)
data_sets.df$name <- as.factor(data_sets.df$name)
data_sets.df$day<- as.factor(data_sets.df$day)
data_sets.df$experimental <- gsub("_", "-", data_sets.df$experimental)
data_sets.df$experimental<- as.factor(data_sets.df$experimental)
data_sets.df$subgroups<- as.factor(data_sets.df$subgroups)
data_sets.df$rep<- as.factor(data_sets.df$rep)

data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,path,readsfile)) %>% distinct() 

```


FAIRE-Seq reads were sequenced for four experimental treatments. Each had one "input" (in which the DNA was fragmented without crosslinking to chromatin) and three replicates in which the DNA was crosslinked and then fragmented. 

```{r echo=FALSE, results='asis'}
data_sets.df.sparse  %>% group_by(experimental,rep) %>% summarise(`sample count`=n())  %>% gt() %>%  tab_options(row_group.background.color = "#FFEFDB") 
```


To accomodate varying data quality, analyses were done on three nested subsets of the data, each including an input and at least one replicate for each experimental treatment. Groups A, B, and C correspond to 1, 2, and 3:

```
ok, do the alignment and MACS2 analysis like you did before.  Do three version: 

1) Only unmarked
2) include the orange
3) all date
```
(Corbin, 20 May 2019 email)

```{r gt table}

data_sets.df %>% select(c(experimental, rep, subgroups)) %>% mutate(dummy="1") %>% filter(subgroups!='all') %>% group_by_at(vars(-dummy)) %>%  mutate(rowid=1:n()) %>% ungroup() %>% spread(key=subgroups, value=dummy ) %>%  select(-rowid) %>% mutate(A=case_when(is.na(A) ~ "x", TRUE ~ "o" ), B=case_when(is.na(B) ~ "x", TRUE ~ "o" ) , C=case_when(is.na(C) ~ "x", TRUE ~ "o" )  ) %>% gt() %>% tab_style(style = cells_styles(text_style = "italic", text_color="red"), locations = list(cells_data(columns = vars(A), rows = A=="x"), cells_data(columns = vars(B), rows = B=="x")))

```


### Pre-Processing

These reads were preprocessed with FASTP [@Chen2018] for quality control and analytics. 


```{r echo=FALSE, include=FALSE, warning=FALSE}
fastp_summary <- read_delim("meta/sequenced_reads.dat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(fastp_summary ) <- c("name","type","measure","value")
fastp_summary$name <- as.factor(fastp_summary$name)
fastp_summary$type <- as.factor(fastp_summary$type)
fastp_summary$measure <- as.factor(fastp_summary$measure)
```


```{r echo=FALSE, include=FALSE, warning=FALSE}
filtration_stats <- inner_join(fastp_summary %>%  filter(type=="prefiltered" | type == 'postfiltered'), data_sets.df.sparse, by=c("name"="name"))
filtration_stats$type <- factor(filtration_stats$type, levels=c("prefiltered", "postfiltered"))
```


Starting FASTQ files contained a total of  $`r sum( filtration_stats %>% filter(type =='prefiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$ reads; after QC, this dropped to $`r sum( filtration_stats %>% filter(type =='postfiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$. 



```{r echo=FALSE, warning=FALSE, message=FALSE }
pre_post_counts <- filtration_stats %>% filter(measure=='total_reads') %>%  group_by(type)  %>%  summarise(minimum = min(value), average=mean(value) , maximum = max(value)) 
retention_percent <- filtration_stats %>% filter(measure=='total_reads') %>% select(c(name,type,value)) %>%  spread(type,value) %>% mutate(retention=100*postfiltered/prefiltered) %>%  summarise(type='percent retention', minimum = min(retention), average=mean(retention) , maximum = max(retention))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
rbind(pre_post_counts, retention_percent) %>% rename(" "=type) %>% gt() %>% tab_header(title="Read Retention Rate during Preprocessing", subtitle= md("&nbsp;")) %>%  fmt_number(columns = vars(minimum, average,maximum),suffixing = TRUE, decimals=0)
```



```{r echo=FALSE, warning=FALSE}
ggplot(filtration_stats %>% filter(measure == "q30_rate")) + geom_line(aes(group=name, x=type,y=100*value)) +  geom_point(aes(x=type, y = 100*value, color=experimental, shape=rep)) + labs(title = "Percent of Reads with a mean QUAL > 30", y="Percent QUAL > 30", x="") + ggbio::theme_clear() + geom_text(data= . %>% filter(type=="postfiltered") %>% filter(value<0.97), aes(type,100*value,label=name))

```


Duplicate reads were also detected; however, duplicate reads are less concerning in FAIRE-seq given the relatively smaller genome they are sampled from. 

https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/8%20Duplicate%20Sequences.html
http://seqanswers.com/forums/showthread.php?t=40440


```{r echo=FALSE, include=FALSE}
dupe_stats <- inner_join(fastp_summary %>% filter(type=='duplication' & measure =='rate') %>%  mutate(percent=value*100) %>% select(c(name,percent)), data_sets.df.sparse, by=c("name"="name"))
```

```{r echo=FALSE}
dupe_stats %>%  summarise(minimum = min(percent), average=mean(percent), median=median(percent) , maximum = max(percent)) %>% gt() %>% tab_header(title="Percentage Duplication", subtitle="FASTP estimate") %>% fmt_number(columns=vars(minimum,median,average,maximum), decimals=1, ) #kable(caption="Percentage Duplication",digits=1)
```

```{r echo=FALSE}
ggplot(dupe_stats) + geom_histogram(aes(x=percent, fill=experimental), bins=15) + labs(title="Duplication Histogram", x="Read Duplication Rate (FASTP estimate)", y="Number Samples") + ggbio::theme_clear()
```




## Mapped Reads

Reads were first mapped to the reference genome using the BWA SAMPE/SE algorithm. Currently, multimapping reads are assigned randomly and the alignments are used unfiltered. 

```{r echo=FALSE, include=FALSE}

vs_dm6.bwa <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwa.summary",aligner="bwa", reference="dm6")
#vs_dm6.bwaUniq <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwaUniq.summary",aligner="bwaUniq", reference="dm6")

all_alignments <- rbind(vs_dm6.bwa)#, vs_dm6.bwaUniq)
```




### Read & Alignment Quality


```{r echo=FALSE, warning=FALSE}
readcount_process <- all_alignments %>%  filter( measure=='total_read_count'| measure == 'total_mapped_count' ) %>% select(-c(reference, aligner))

readcount_process$measure <- factor(readcount_process$measure, levels = c('total_read_count','total_mapped_count'))
```

The mapping rate per sample can be calculated from the number of mapped reads compared to the total number of sequenced reads:

```{r echo=FALSE, warning=FALSE}
ggplot(inner_join(readcount_process%>% mutate(measure=gsub("_"," ",measure)), data_sets.df.sparse, by=c("sample"="name"))) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample,color=experimental, shape=rep))  + labs(title="Read Counts by Processing Step: Unmapped, Mapped, Filtered", x="", y="Number Reads" ) + ggbio::theme_clear() + theme(axis.text.x = element_text(angle = -45, hjust = 0), legend.position='none' ) + scale_y_log10()

```

```{r echo=FALSE}

readcount_process.spread <- readcount_process %>%  spread(measure, value) %>%  mutate(percent_mapping=100*total_mapped_count/total_read_count)#, filter_retention = filtered_mapped_count/total_mapped_count)


readcount_process.spread %>% gather(total_read_count:percent_mapping, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>% mutate(measure=gsub("_"," ",measure)) %>% gt()  %>% tab_header(title="Read Counts During Alignment & Filtration", subtitle= md("&nbsp;")) %>% fmt_number(columns=vars(minimum, average, median, maximum), rows =c(2,3), decimals=1, suffixing=TRUE)%>% fmt_number(columns=vars(minimum, average, median, maximum), rows =c(1), decimals=2)


```



## Peak Calling

MACS was used to QC pilot data, but it wasn't designed for use on FAIRE-Seq. MACS2 was extended for use with FAIRE (  https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/1756-8935-7-33 ) but has its own difficulties, such as python2/3 incompatibilities, and only running on all samples under inhomogeneous settings. Here, Fseq [@Boyle2008] is used to infer peaks from mapped reads. It does this using a kernel density estimation to find intervals with significantly (4 sigma by default) more mapped reads than expected from the average regional coverage. Additionally, a signal strength is calculated, as the highest kernel density in the interval, scaled by interval size. 

```{r echo=FALSE, warning=FALSE, message=FALSE}

basicPeakStats_vs_dm6_bwa <- read_delim("meta/basicPeakStats.vs_dm6.bwa.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% as_tibble()
names(basicPeakStats_vs_dm6_bwa ) <- c("sample","dataType","dataSubtype","value")
basicPeakStats_vs_dm6_bwa$sample <- as.factor(basicPeakStats_vs_dm6_bwa$sample)
basicPeakStats_vs_dm6_bwa$dataType<- as.factor(basicPeakStats_vs_dm6_bwa$dataType)
basicPeakStats_vs_dm6_bwa$dataSubtype<- as.factor(basicPeakStats_vs_dm6_bwa$dataSubtype)

```

from the $`r basicPeakStats_vs_dm6_bwa %>% select(sample) %>% unique() %>% count() `$ samples,  $`r basicPeakStats_vs_dm6_bwa %>% filter(dataType=="count" & dataSubtype == "total") %>% select(value) %>% sum() %>% human_readable_croncher() `$ total peaks were called:

```{r echo=FALSE}
basicPeakStats_vs_dm6_bwa.count.sprud <- basicPeakStats_vs_dm6_bwa %>% filter(dataType == "count") %>% select(-c(dataType)) %>% spread(dataSubtype,value)

contigs <- basicPeakStats_vs_dm6_bwa.count.sprud %>% select(3:ncol(.)-1) %>% names()

basicPeakStats_vs_dm6_bwa.count.sprud %>% gt()  %>%  tab_spanner(label="by contig", columns=vars(contigs )) %>% fmt_number(columns = seq(2,10),  decimals = 1, suffixing = T)   %>% tab_header(title="Called Peak Count", subtitle= "by contig and sample")

```

We can also check the peak-calling efficiency:


```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.count.sprud.aug <- inner_join(inner_join(basicPeakStats_vs_dm6_bwa.count.sprud %>% select(c("sample","total")), data_sets.df.sparse , by = c("sample"="name")), readcount_process.spread, by=c("sample"="sample")) %>% rename("total_peak_count"=total) %>% mutate(peaks_per_thousand_sequenced_reads = 1000*total_peak_count/total_read_count, peaks_per_thousand_mapped_reads = 1000*total_peak_count/total_mapped_count)

basicPeakStats_vs_dm6_bwa.count.sprud.aug  %>% select(-c("sample", "day")) %>% select_all(~gsub("_"," ",.)) %>%  gt() %>% cols_move_to_start(columns = vars(experimental, rep)) %>% fmt_number(columns = vars(`total peak count`), suffixing = T, decimals = 1) %>% fmt_number(columns = vars(`peaks per thousand sequenced reads`, `peaks per thousand mapped reads`),  decimals = 1) %>% cols_hide(columns=vars(`total read count`, `total mapped count`, `percent mapping`)) %>% cols_label(`peaks per thousand sequenced reads` = "peaks per\nthousand sequenced reads", `peaks per thousand mapped reads`= "peaks per\nthousand mapped reads")  %>% tab_header(title="Peak Calling Efficiency", subtitle= "peaks called per read sequenced/mapped")

```

### Raw Peaks

```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.size.sprud <- basicPeakStats_vs_dm6_bwa %>% filter(dataType == "width" | dataType == "signal") %>% unite(dataSubtype, dataType, col="measure", sep=" ")  %>% spread(measure, value) %>% select(sample, `avg width`, `std width`, `avg signal`, `std signal`)

basicPeakStats_vs_dm6_bwa.size.sprud.aug <- inner_join(inner_join(basicPeakStats_vs_dm6_bwa.size.sprud, data_sets.df.sparse , by = c("sample"="name")),readcount_process.spread, by=c("sample"="sample") )

	
grand_mean_peak_width <- mean(basicPeakStats_vs_dm6_bwa.size.sprud$`avg width`)
grand_mean_signal <- mean(basicPeakStats_vs_dm6_bwa.size.sprud$`avg signal`)
```

peaks had an average width of $`r human_readable_croncher(grand_mean_peak_width) `$ base pairs. Peaks also had intensity values measuring signal enhancement over the genomic background; these averaged at $`r human_readable_croncher(grand_mean_signal) `$ Both of these values were highly variable within and between samples:

```{r gt, echo=FALSE}

basicPeakStats_vs_dm6_bwa.size.sprud.aug %>% select(experimental, rep, `avg width`, `std width`, `avg signal`, `std signal`) %>% gt() %>%  tab_spanner(label="width", columns=vars( `avg width`, `std width`)) %>%  tab_spanner(label="signal", columns=vars( `avg signal`, `std signal` )) %>% fmt_number(columns = vars(`avg width`, `std width`, `avg signal`, `std signal` ), decimals = 1, suffixing = F) %>% tab_header(title="Peak Size & Signal Strength", subtitle= md("&nbsp;")) %>% cols_label(`avg width` = "avg", `std width` = "std", `avg signal` = "avg", `std signal` = "std" )

```

```{r echo=FALSE}

basicPeakStats_vs_dm6_bwa.full.sprud.aug <- inner_join(basicPeakStats_vs_dm6_bwa.size.sprud.aug, basicPeakStats_vs_dm6_bwa.count.sprud.aug %>% select(-c(experimental,day,rep, total_read_count, total_mapped_count, percent_mapping)), by=c("sample"="sample")  )


basicPeakStats_vs_dm6_bwa.full.sprud.aug.names <- basicPeakStats_vs_dm6_bwa.full.sprud.aug %>% names()
names(basicPeakStats_vs_dm6_bwa.full.sprud.aug) <- gsub(" ","\n", gsub("_", "\n", basicPeakStats_vs_dm6_bwa.full.sprud.aug %>% names()))

ggscatmat(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg\nwidth", "std\nwidth", "avg\nsignal", "std\nsignal", "total\nread\ncount", "total\nmapped\ncount", "total\npeak\ncount" )) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title="Distributions & Correlations for Read and Peak Stats")

#ggscatmat(basicPeakStats_vs_dm6_bwa.full.sprud.aug, columns = c("avg\nwidth", "avg\nsignal", "total\nread\ncount", "total\nmapped\ncount", "percent\nmapping",  "total\npeak\ncount" ), color="experimental") + theme(axis.text.x = element_text(angle = 90, hjust = 1))

names(basicPeakStats_vs_dm6_bwa.full.sprud.aug) <- basicPeakStats_vs_dm6_bwa.full.sprud.aug.names 

```



```{r echo=FALSE, message=FALSE}
raw_called_peaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$name) {
	
	tmp.df <- read_delim(paste("fSeq/",nom,".vs_dm6.bwa.calledPeaks.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE) %>% select(X1,X2,X3,X7,X10)
	names(tmp.df) <- c("chrom", "start", "stop", "signal", "center")
	tmp.df$sample <- as.factor(nom)
	raw_called_peaks.df <- rbind(raw_called_peaks.df, tmp.df)
}

raw_called_peaks.df <- raw_called_peaks.df %>% as_tibble()
raw_called_peaks.df$chrom <- as.factor(raw_called_peaks.df$chrom)

raw_called_peaks.df$peak_width <- raw_called_peaks.df$stop - raw_called_peaks.df$start
raw_called_peaks.df <- inner_join(raw_called_peaks.df, data_sets.df.sparse, by=c("sample"="name"))

```


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
of the $`r basicPeakStats_vs_dm6_bwa %>% filter(dataType=="count" & dataSubtype == "total") %>% select(value) %>% sum() %>% human_readable_croncher() `$ peaks, $`r raw_called_peaks.df %>% filter(peak_width==0) %>% nrow() %>% human_readable_croncher() `$ had a width of zero
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


```
There shouldn’t be any peaks that consist of zero bases – if you’re looking at the narrow peak file, then the start and end positions should never be the same (which would indicate zero bases). It is a zero-based position, so a peak with coordinates chr1:1000-1001 is a 1bp peak at chr1:1001. [...] I’ve cc’d Alan Boyle, who wrote the software, to confirm that there should not be any zero-width peaks. I’m at a loss here – I don’t think we’ve encountered this before.
(emails from Terry Furey, 6 Aug 2019)
```


```{r echo=FALSE, warning=FALSE}

ggplot(raw_called_peaks.df %>% gather(signal, peak_width, key="measure", value="value")) + geom_histogram(aes(x=value, fill=experimental), bins=50) +facet_grid(chrom~measure, scales="free") + scale_x_log10() + theme_bw() + labs(title="Histogram of Peak Width & Signal Strength,\nby Chromosome")

```

The consistent spike in peak width in the 47b1-7 experiment, slightly above 1kb, comes from replicate 3. This sample has an order of magnitude more peaks large than 1kb, than the other 15.

```{r echo=FALSE}
raw_called_peaks.df %>% filter(peak_width > 1000 )  %>% group_by(experimental, rep) %>% summarize(n=n()) %>%  spread(rep, n) %>% ungroup() %>% gt() %>% tab_options(footnote.glyph = c("*")) %>% tab_style(style=cells_styles(text_color='red'), locations=list(cells_data(columns=vars(3), rows=experimental == "47b1-7"))) %>%  tab_footnote(footnote = "  ", locations=list(cells_data(columns=vars(3), rows=experimental == "47b1-7"))) %>% tab_header(title="Number of Peaks Larger than 1 kb", subtitle= "by experiment and replicate")

```

47b1-7 replicate #3 is only included in the "C" analysis group (Section 2.6). 


check intrasample, inter-peak distances: look for potentially non-distinct peaks. 
```{r echo=FALSE, message=FALSE}

calledPeaks.selfDistance.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$name) {
	tmp.df <- read_delim(paste("fSeq/closest/all/",nom,".to.",nom,  ".vs_dm6.bwa.closestPeaks.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE, guess_max = 1000000)
	#names(tmp.df) <- c("chrom", "start", "stop", "signal", "center")
	calledPeaks.selfDistance.df  <- rbind(calledPeaks.selfDistance.df , tmp.df)
}

calledPeaks.selfDistance.df <- calledPeaks.selfDistance.df  %>% as_tibble() %>% select(c(X1,X2,X3,X7,X10,X11,X12,X13,X17,X20,X21,X22))
names(calledPeaks.selfDistance.df) <- c("chrom1", "start1", "stop1", "signal1", "center1", "chrom2", "start2", "stop2", "signal2", "center2", "distance", "sample" )
calledPeaks.selfDistance.df$chrom1 <- as.factor(calledPeaks.selfDistance.df$chrom1)
calledPeaks.selfDistance.df$chrom2 <- as.factor(calledPeaks.selfDistance.df$chrom2)
calledPeaks.selfDistance.df$sample <- as.factor(calledPeaks.selfDistance.df$sample)

calledPeaks.selfDistance.df <- inner_join(calledPeaks.selfDistance.df, data_sets.df.sparse, by=c("sample"="name"))


```


The distance between adjacent peaks within a sample was measured. 


```{r echo=FALSE}

ggplot(calledPeaks.selfDistance.df %>% filter(chrom1 != "chrM")) + geom_freqpoly(aes(x=abs(distance), color=rep), bins=50) + facet_grid(experimental ~ chrom1) + scale_x_log10() +theme_bw()+ theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Distance Between Adjacent Peaks,\nby sample and replicate", x= "distance (bp)")

```

Some peaks were very close to other peaks; as many as 20% of peaks were within 10bp of another one, and as many as 65% were within 100 bp:

```{r echo=FALSE}
closePeaks <- calledPeaks.selfDistance.df %>% filter(abs(distance)<10) %>% group_by(sample) %>% summarise(lessThan10 = n() )
closePeaks <- cbind( closePeaks, calledPeaks.selfDistance.df %>% filter(abs(distance)<100) %>% group_by(sample) %>% summarise(lessThan100 = n() ) %>% select(lessThan100))

#closePeaks <- 
inner_join(closePeaks, basicPeakStats_vs_dm6_bwa.full.sprud.aug, by=c("sample"="sample")) %>% mutate(lessThan10 = lessThan10/total_peak_count, lessThan100 = lessThan100/total_peak_count, potato = "")  %>% select(experimental, rep, lessThan10, lessThan100, potato) %>% group_by(experimental) %>% gt(rowname_col = "potato") %>% fmt_percent(columns=vars(lessThan10, lessThan100), decimals = 1) %>% tab_stubhead_label(label="experimental treatment") %>% cols_label(lessThan10 = "< 10 bp", lessThan100 = "< 100 bp") %>% tab_header(title="Percentage of Peaks Very Close to Other Peaks", subtitle= "within a sample")

#ggplot(calledPeaks.selfDistance.df %>% mutate(one=stop1-start1, two = stop2-start2, distance=abs(distance)) %>% select(one, two, distance, experimental, rep) %>% gather(one, two, key="peak", value="width") ) + geom_point(aes(x=distance, y=width), alpha=0.1) + facet_grid(.~peak)

```

### Collapsed Peaks ( within input/output )

Although the inputs consisted of a single replicate, each experimental output had three replicates. These were collapsed into a single set of peaks each for every input and output. The collapsed peak region was defined as the union of all peaks being considered. Calculating a combined signal value for multiple peaks is an open problem; several approaches are tested here:
```
	* Average: a flat average of the component peaks' signal values
	* Rescale: in which the component peaks' maximum kernel densities are averaged, and then scaled by final peak width
	* Weighted: like Rescale, but the average max kernel density is weighted by the component peak widths
	* Pessimistic: like weighted, but the result is further scaled by the fraction of replicates supporting a peak in this region.  
	* Fine: (in development)
```

All strategies but Average will give NA for singleton zero-width peaks. 



```{r echo=FALSE}

collapsedPeaks.df <-as.data.frame(c()) 
for (nom in data_sets.df.sparse$experimental) {
	
#	for (treat in c("input","output")){
	for (treat in c("output")){		
		for (grup in c("A", "B", "C")) {
			tmp.df <- read_delim(paste("fSeq/collapsed/",gsub("-", "_", nom),".vs_dm6.bwa.","group_",grup,".",treat,".signalsCollapsed.bed", sep=""), "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
			names(tmp.df) <- c("chrom", "start", "stop", "count", "avg", "rescale", "weight", "pess")
			tmp.df$chrom <- as.factor(tmp.df$chrom)
			tmp.df$treat <- as.factor(treat)
			tmp.df$experimental <- as.factor(nom)
			tmp.df$group <- as.factor(grup)
			collapsedPeaks.df <- rbind(collapsedPeaks.df, tmp.df)
		}
	}
}

collapsedPeaks.df <- collapsedPeaks.df %>% as_tibble()

collapsedPeaks.df$peak_width <- collapsedPeaks.df$stop - collapsedPeaks.df$start


```

Since the inputs consist of one replicate each, their collapsed peaks are identical to their raw peaks (except for those with a width of zero, whose collapsed signal strengths are NA except for the flat average). In the case of the outputs, with 1-3 replicates depending on experimental treatment and 


```{r echo=FALSE}

collapsedPeaks.gath <- collapsedPeaks.df %>%  gather(key = "measure", value = "value", c(avg, rescale, weight, pess))

measureList <- levels(collapsedPeaks.gath$measure)
collapsedPeaks.gath$measure<- as.factor(collapsedPeaks.gath$measure)
measureList <- levels(collapsedPeaks.gath$measure)
collapsedPeaks.gath$measure <- factor(collapsedPeaks.gath$measure, levels = c("raw", measureList ))

raw_called_peaks.signlXtract <- raw_called_peaks.df %>%  mutate(measure = as.factor("raw"))
raw_called_peaks.signlXtract$measure <- factor(raw_called_peaks.signlXtract$measure, levels = c("raw", measureList ))



hiPass.raw <- raw_called_peaks.signlXtract %>% filter(rep != "input") %>% mutate(high = signal > 20) %>% group_by(high) %>% summarize( count = n()) %>% mutate( frac = count/sum(count))
hiPass.clps <- collapsedPeaks.gath  %>% mutate(high = value > 20) %>% group_by(high) %>% summarize( count = n()) %>% mutate( frac = count/sum(count))



```

When the small number (`r  human_readable_croncher(hiPass.raw$frac[2]*100)` percent of raw peaks,  `r  human_readable_croncher(hiPass.clps$frac[2]*100) ` percent of collapsed peaks ) of high-signal outliers  (raw or collapsed signal > 20) were excluded, the distributions of the raw/collapsed signals were as follows

```{r echo=FALSE}

ggplot(collapsedPeaks.gath %>%  filter(value<20)) + geom_violin(data = inner_join(raw_called_peaks.signlXtract %>% filter(rep != "input") %>% select(sample, signal, rep, measure),data_sets.df %>% filter(subgroups != "all" & rep != "input") %>% select(name, subgroups, experimental) %>% rename(group=subgroups),by=c("sample"="name")) %>%  filter(signal<20), aes(x=measure, y=signal, fill=rep)) + geom_violin(aes(x=measure, y=value)) + facet_grid(group~experimental) + scale_y_log10() + scale_x_discrete(limits=c("raw", "avg", "rescale", "weight", "pess")) + labs(x = "signal type", y= "signal intensity", title="Comparison of Signal-Merging Strategies\n( Outliers with Intensity > 20 Removed)")

```

```{r echo=FALSE}
ggscatmat(collapsedPeaks.df %>% mutate(macks = pmax(avg, rescale, weight, pess)) %>%  filter(macks<20) %>% sample_n(420000), columns = c( "avg", "rescale", "weight", "pess" ))# + theme(axis.text.x = element_text(angle = 90, hjust = 1))# + labs(title="Distributions & Correlations for Read and Peak Stats")

```




ggscattercorr + naniar::geom_miss_point ?


### Merged Peaks (proximity within input/output)

Once the peaks have been collapsed within a treatment, the issue of nearby peaks not being distinct remains. It is trivial to merge nearby peaks into a single feature, but the issue of how to combine signal strengths remains. 





	
# Bibliography
```{r echo=FALSE}

citation("topGO")
citation("ggplot2")
citation("GGally")
citation("ggnewscale")


```

